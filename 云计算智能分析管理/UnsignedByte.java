package de.innosystec.zhinengguanli.unpack;import de.innosystec.zhinengguanli.exception.RarException;import de.innosystec.zhinengguanli.rarfile.FileHeader;import de.innosystec.zhinengguanli.unpack.ppm.BlockTypes;import de.innosystec.zhinengguanli.unpack.ppm.ModelPPM;import de.innosystec.zhinengguanli.unpack.ppm.SubAllocator;import de.innosystec.zhinengguanli.unpack.vm.BitInput;import de.innosystec.zhinengguanli.unpack.vm.RarVM;import de.innosystec.zhinengguanli.unpack.vm.VMPreparedProgram;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Vector;public final class Unpack extends Unpack20{  private final ModelPPM ppm = new ModelPPM();  private int ppmEscChar;  private RarVM rarVM = new RarVM();  private List<UnpackFilter> filters = new ArrayList();  private List<UnpackFilter> prgStack = new ArrayList();  private List<Integer> oldFilterLengths = new ArrayList();  private int lastFilter;  private boolean tablesRead;  private byte[] unpOldTable = new byte[404];  private BlockTypes unpBlockType;  private boolean externalWindow;  private long writtenFileSize;  private boolean fileExtracted;  private boolean ppmError;  private int prevLowDist;  private int lowDistRepCount;  public static int[] DBitLengthCounts = { 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,     2, 2, 2, 2, 2, 14, 0, 12 };  public Unpack(ComprDataIO DataIO)  {    this.unpIO = DataIO;    this.window = null;    this.externalWindow = false;    this.suspended = false;    this.unpAllBuf = false;    this.unpSomeRead = false;  }  public void init(byte[] window)  {    if (window == null) {      this.window = new byte[4194304];    } else {      this.window = window;      this.externalWindow = true;    }    this.inAddr = 0;    unpInitData(false);  }  public void doUnpack(int method, boolean solid) throws IOException, RarException  {    if (this.unpIO.getSubHeader().getUnpMethod() == 48) {      unstoreFile();    }    switch (method) {    case 15:      unpack15(solid);      break;    case 20:    case 26:      unpack20(solid);      break;    case 29:    case 36:      unpack29(solid);    }  }  private void unstoreFile()    throws IOException, RarException  {    byte[] buffer = new byte[65536];    while (true) {      int code = this.unpIO.unpRead(buffer, 0, (int)Math.min(buffer.length, this.destUnpSize));      if ((code == 0) || (code == -1))        break;      code = code < this.destUnpSize ? code : (int)this.destUnpSize;      this.unpIO.unpWrite(buffer, 0, code);      if (this.destUnpSize >= 0L)    this.destUnpSize -= code;  }} private boolean readVMCodePPM() throws IOException, RarException  {    int FirstByte = this.ppm.decodeChar();    if (FirstByte == -1) {  } protected void huffDecode()  {    int BitField = fgetbits();    int BytePlace;    int BytePlace;    if (this.AvrPlc > 30207) {      BytePlace = decodeNum(BitField, 8, DecHf4, PosHf4);    }    else    {      int BytePlace;      if (this.AvrPlc > 24063) {        BytePlace = decodeNum(BitField, 6, DecHf3, PosHf3);      }      else      {        int BytePlace;        if (this.AvrPlc > 13823) {          BytePlace = decodeNum(BitField, 5, DecHf2, PosHf2);        }       }        else        {          int BytePlace;          if (this.AvrPlc > 3583)          else {     BytePlace = decodeNum(BitField, 4, DecHf0,      PosHf0);    }  } }  private boolean addVMCode(int firstByte, List<Byte> vmCode, int length)  {    BitInput Inp = new BitInput();    Inp.InitBitInput();    for (int i = 0; i < Math.min(32768, vmCode.size()); i++) {      Inp.getInBuf()[i] = ((Byte)vmCode.get(i)).byteValue();    }    this.rarVM.init();    int FiltPos;    if ((firstByte & 0x80) != 0) {      int FiltPos = RarVM.ReadData(Inp);      if (FiltPos == 0)        initFilters();      else        FiltPos--;    }    else {      FiltPos = this.lastFilter;    }    if ((FiltPos > this.filters.size()) || (FiltPos > this.oldFilterLengths.size())) {      return false;    }    this.lastFilter = FiltPos;    boolean NewFilter = FiltPos == this.filters.size();    UnpackFilter StackFilter = new UnpackFilter();    UnpackFilter Filter;    if (NewFilter)    {      if (FiltPos > 1024) {        return false;      }      UnpackFilter Filter = new UnpackFilter();      this.filters.add(Filter);      StackFilter.setParentFilter(this.filters.size() - 1);      this.oldFilterLengths.add(Integer.valueOf(0));      Filter.setExecCount(0);    }    else {      Filter = (UnpackFilter)this.filters.get(FiltPos);      StackFilter.setParentFilter(FiltPos);      Filter.setExecCount(Filter.getExecCount() + 1);    }    this.prgStack.add(StackFilter);    StackFilter.setExecCount(Filter.getExecCount());    int BlockStart = RarVM.ReadData(Inp);    if ((firstByte & 0x40) != 0) {      BlockStart += 258;    }    StackFilter.setBlockStart(BlockStart + this.unpPtr & 0x3FFFFF);    if ((firstByte & 0x20) != 0)      StackFilter.setBlockLength(RarVM.ReadData(Inp));    else {      StackFilter        .setBlockLength(FiltPos < this.oldFilterLengths.size() ?         ((Integer)this.oldFilterLengths.get(FiltPos)).intValue() :         0);    }    StackFilter.setNextWindow((this.wrPtr != this.unpPtr) &&       ((this.wrPtr - this.unpPtr & 0x3FFFFF) <= BlockStart));    this.oldFilterLengths.set(FiltPos, Integer.valueOf(StackFilter.getBlockLength()));    Arrays.fill(StackFilter.getPrg().getInitR(), 0);    StackFilter.getPrg().getInitR()[3] = 245760;    StackFilter.getPrg().getInitR()[4] = StackFilter.getBlockLength();    StackFilter.getPrg().getInitR()[5] = StackFilter.getExecCount();    if ((firstByte & 0x10) != 0)    {      int InitMask = Inp.fgetbits() >>> 9;      Inp.faddbits(7);      for (int I = 0; I < 7; I++) {        if ((InitMask & 1 << I) != 0)        {          StackFilter.getPrg().getInitR()[I] = RarVM.ReadData(Inp);        }      }    }    if (NewFilter) {      int VMCodeSize = RarVM.ReadData(Inp);      if ((VMCodeSize >= 65536) || (VMCodeSize == 0)) {        return false;      }      byte[] VMCode = new byte[VMCodeSize];      for (int I = 0; I < VMCodeSize; I++) {        if (Inp.Overflow(3)) {          return false;        }        VMCode[I] = ((byte)(Inp.fgetbits() >> 8));        Inp.faddbits(8);      }      this.rarVM.prepare(VMCode, VMCodeSize, Filter.getPrg());    }    StackFilter.getPrg().setAltCmd(Filter.getPrg().getCmd());    StackFilter.getPrg().setCmdCount(Filter.getPrg().getCmdCount());    int StaticDataSize = Filter.getPrg().getStaticData().size();    if ((StaticDataSize > 0) && (StaticDataSize < 8192))    {      StackFilter.getPrg().setStaticData(Filter.getPrg().getStaticData());    }    if (StackFilter.getPrg().getGlobalData().size() < 64)    {      StackFilter.getPrg().getGlobalData().clear();      StackFilter.getPrg().getGlobalData().setSize(        64);    }    Vector globalData = StackFilter.getPrg().getGlobalData();    for (int I = 0; I < 7; I++) {      this.rarVM.setLowEndianValue(globalData, I * 4,         StackFilter.getPrg().getInitR()[I]);    }    this.rarVM.setLowEndianValue(globalData, 28, StackFilter.getBlockLength());    this.rarVM.setLowEndianValue(globalData, 32, 0);    this.rarVM.setLowEndianValue(globalData, 36, 0);    this.rarVM.setLowEndianValue(globalData, 40, 0);    this.rarVM.setLowEndianValue(globalData, 44, StackFilter.getExecCount());    for (int i = 0; i < 16; i++) {      globalData.set(48 + i, Byte.valueOf((byte)0));    }    if ((firstByte & 0x8) != 0)    {      if (Inp.Overflow(3)) {        return false;      }      int DataSize = RarVM.ReadData(Inp);      if (DataSize > 8128) {        return false;      }      int CurSize = StackFilter.getPrg().getGlobalData().size();      if (CurSize < DataSize + 64)      {        StackFilter.getPrg().getGlobalData().setSize(          DataSize + 64 - CurSize);      }      int offset = 64;      globalData = StackFilter.getPrg().getGlobalData();      for (int I = 0; I < DataSize; I++) {        if (Inp.Overflow(3)) {          return false;        }        globalData.set(offset + I,           Byte.valueOf((byte)(Inp.fgetbits() >>> 8)));        Inp.faddbits(8);      }    }    return true;  }    BytePlace &= 255;    if (this.StMode != 0) {      if ((BytePlace == 0) && (BitField > 4095)) {        BytePlace = 256;      }      BytePlace--; if (BytePlace == -1) {        BitField = fgetbits();        faddbits(1);        if ((BitField & 0x8000) != 0) {          this.NumHuf = (this.StMode = 0);          return;        }        int Length = (BitField & 0x4000) != 0 ? 4 : 3;        faddbits(1);        int Distance = decodeNum(fgetbits(), 5, DecHf2, PosHf2);        Distance = Distance << 5 | fgetbits() >>> 11;        faddbits(5);        oldCopyString(Distance, Length);      }    }    else if ((this.NumHuf++ >= 16) && (this.FlagsCnt == 0)) {      this.StMode = 1;    }    this.AvrPlc += BytePlace;    this.AvrPlc -= (this.AvrPlc >>> 8);    this.Nhfb += 16;    if (this.Nhfb > 255) {      this.Nhfb = 144;      this.Nlzb >>>= 1;    }    this.window[(this.unpPtr++)] = ((byte)(this.ChSet[BytePlace] >>> 8));    this.destUnpSize -= 1L;    while (true)    {      int CurByte = this.ChSet[BytePlace];      int tmp421_420 = (CurByte++ & 0xFF);      int[] tmp421_410 = this.NToPl;      int tmp423_422 = tmp421_410[tmp421_420]; tmp421_410[tmp421_420] = (tmp423_422 + 1); int NewBytePlace = tmp423_422;      if ((CurByte & 0xFF) <= 161) break;      corrHuff(this.ChSet, this.NToPl);    }    int NewBytePlace;    int CurByte;    this.ChSet[BytePlace] = this.ChSet[NewBytePlace];    this.ChSet[NewBytePlace] = CurByte;  }  protected void getFlagsBuf()  {    int FlagsPlace = decodeNum(fgetbits(), 5, DecHf2, PosHf2);    while (true)    {      int Flags = this.ChSetC[FlagsPlace];      this.FlagBuf = (Flags >>> 8);      int tmp43_42 = (Flags++ & 0xFF);      int[] tmp43_32 = this.NToPlC;      int tmp45_44 = tmp43_32[tmp43_42]; tmp43_32[tmp43_42] = (tmp45_44 + 1); int NewFlagsPlace = tmp45_44;      if ((Flags & 0xFF) != 0) {        break;      }      corrHuff(this.ChSetC, this.NToPlC);    }    int NewFlagsPlace;    int Flags;    this.ChSetC[FlagsPlace] = this.ChSetC[NewFlagsPlace];    this.ChSetC[NewFlagsPlace] = Flags;  }  protected void oldUnpInitData(boolean Solid)  {    if (!Solid) {      this.AvrPlcB = (this.AvrLn1 = this.AvrLn2 = this.AvrLn3 = this.NumHuf = this.Buf60 = 0);      this.AvrPlc = 13568;      this.MaxDist3 = 8193;      this.Nhfb = (this.Nlzb = '€');    }    this.FlagsCnt = 0;    this.FlagBuf = 0;    this.StMode = 0;    this.LCount = 0;    this.readTop = 0;  }  protected void initHuff()  {    for (int I = 0; I < 256; I++)    {      int tmp23_22 = (this.PlaceB[I] = I); this.PlaceA[I] = tmp23_22; this.Place[I] = tmp23_22;      this.PlaceC[I] = ((I ^ 0xFFFFFFFF) + 1 & 0xFF);      int tmp55_54 = (I << 8); this.ChSetB[I] = tmp55_54; this.ChSet[I] = tmp55_54;      this.ChSetA[I] = I;      this.ChSetC[I] = (((I ^ 0xFFFFFFFF) + 1 & 0xFF) << 8);    }  }  protected void corrHuff(int[] CharSet, int[] NumToPlace)  {    int pos = 0;    for (int I = 7; I >= 0; I--) {      for (int J = 0; J < 32; pos++) {        CharSet[pos] = (CharSet[pos] & 0xFFFFFF00 | I);        J++;      }    }    Arrays.fill(NumToPlace, 0);    for (I = 6; I >= 0; I--)      NumToPlace[I] = ((7 - I) * 32);  }  protected void oldCopyString(int Distance, int Length)  {    this.destUnpSize -= Length;    while (Length-- != 0) {      this.window[this.unpPtr] = this.window[(this.unpPtr - Distance & 0x3FFFFF)];   this.unpPtr = (this.unpPtr + 1 & 0x3FFFFF);  }} protected boolean ReadTables20() throws IOException, RarException  {    byte[] BitLength = new byte[19];    byte[] Table = new byte[1028];    if ((this.inAddr > this.readTop - 25) &&       (!unpReadBuf())) {      return false;    }    int BitField = getbits();    this.UnpAudioBlock = (BitField & 0x8000);    if ((BitField & 0x4000) == 0)    {      Arrays.fill(this.UnpOldTable20, (byte)0);    }    addbits(2);    int TableSize;    int TableSize;    if (this.UnpAudioBlock != 0) {      this.UnpChannels = ((BitField >>> 12 & 0x3) + 1);      if (this.UnpCurChannel >= this.UnpChannels) {        this.UnpCurChannel = 0;      }      addbits(2);      TableSize = 257 * this.UnpChannels;    } else {      TableSize = 374;    }    for (int I = 0; I < 19; I++) {      BitLength[I] = ((byte)(getbits() >>> 12));      addbits(4);    }    makeDecodeTables(BitLength, 0, this.BD, 19);    I = 0;    while (I < TableSize) {      if ((this.inAddr > this.readTop - 5) &&         (!unpReadBuf())) {        return false;      }      int Number = decodeNumber(this.BD);      if (Number < 16) {        Table[I] = ((byte)(Number + this.UnpOldTable20[I] & 0xF));        I++;      } else if (Number == 16) {        int N = (getbits() >>> 14) + 3;        addbits(2);        do {          Table[I] = Table[(I - 1)];          I++;          if (N-- <= 0) break;  } while (I < TableSize);      }      else      {        int N;        if (Number == 17) {          int N = (getbits() >>> 13) + 3;          addbits(3);        } else {          N = (getbits() >>> 9) + 11;          addbits(7);        }        while ((N-- > 0) && (I < TableSize))          Table[(I++)] = 0;      }    }    if (this.inAddr > this.readTop) {      return true;    }    if (this.UnpAudioBlock != 0) {      for (I = 0; I < this.UnpChannels; I++)        makeDecodeTables(Table, I * 257, this.MD[I], 257);    } else {      makeDecodeTables(Table, 0, this.LD, 298);      makeDecodeTables(Table, 298, this.DD, 48);      makeDecodeTables(Table, 346, this.RD,         28);    }    for (int i = 0; i < this.UnpOldTable20.length; i++) {      this.UnpOldTable20[i] = Table[i];    }    return true;  }  protected void unpInitData20(boolean Solid)  {    if (!Solid) {      this.UnpChannelDelta = (this.UnpCurChannel = 0);      this.UnpChannels = 1;      Arrays.fill(this.AudV, new AudioVariables());      Arrays.fill(this.UnpOldTable20, (byte)0);    }  } private void UnpWriteData(byte[] data, int offset, int size)    throws IOException  {    if (this.writtenFileSize >= this.destUnpSize) { } private boolean readEndOfBlock() throws IOException, RarException  {    int BitField = getbits();    boolean NewFile = false;    boolean NewTable;    if ((BitField & 0x8000) != 0) {      boolean NewTable = true;      addbits(1);    } else {      NewFile = true;      NewTable = (BitField & 0x4000) != 0;      addbits(2);    }    this.tablesRead = (!NewTable);    return (!NewFile) && ((!NewTable) || (readTables()));  }  private boolean readTables() throws IOException, RarException  {    byte[] bitLength = new byte[20];    byte[] table = new byte[404];    if ((this.inAddr > this.readTop - 25) &&       (!unpReadBuf())) {      return false;    }    faddbits(8 - this.inBit & 0x7);    long bitField = fgetbits() & 0xFFFFFFFF;    if ((bitField & 0x8000) != 0L) {      this.unpBlockType = BlockTypes.BLOCK_PPM;      return this.ppm.decodeInit(this, this.ppmEscChar);    }    this.unpBlockType = BlockTypes.BLOCK_LZ;    this.prevLowDist = 0;    this.lowDistRepCount = 0;    if ((bitField & 0x4000) == 0L) {      Arrays.fill(this.unpOldTable, (byte)0);    }    faddbits(2);    for (int i = 0; i < 20; i++) {      int length = fgetbits() >>> 12 & 0xFF;      faddbits(4);      if (length == 15) {        int zeroCount = fgetbits() >>> 12 & 0xFF;        faddbits(4);        if (zeroCount == 0) {          bitLength[i] = 15;        } else {          zeroCount += 2;          while ((zeroCount-- > 0) && (i < bitLength.length)) {            bitLength[(i++)] = 0;          }          i--;        }      } else {        bitLength[i] = ((byte)length);      }    }    makeDecodeTables(bitLength, 0, this.BD, 20);    int TableSize = 404;    for (int i = 0; i < TableSize; ) {      if ((this.inAddr > this.readTop - 5) &&         (!unpReadBuf())) {        return false;      }      int Number = decodeNumber(this.BD);      if (Number < 16) {        table[i] = ((byte)(Number + this.unpOldTable[i] & 0xF));        i++;      } else if (Number < 18)      {        int N;        if (Number == 16) {          int N = (fgetbits() >>> 13) + 3;          faddbits(3);        } else {          N = (fgetbits() >>> 9) + 11;          faddbits(7);        }        do {          table[i] = table[(i - 1)];          i++;          if (N-- <= 0) break;  } while (i < TableSize);      }      else      {        int N;        if (Number == 18) {          int N = (fgetbits() >>> 13) + 3;          faddbits(3);        } else {          N = (fgetbits() >>> 9) + 11;          faddbits(7);        }        while ((N-- > 0) && (i < TableSize)) {          table[(i++)] = 0;        }      }    }    this.tablesRead = true;    if (this.inAddr > this.readTop) {      return false;    }    makeDecodeTables(table, 0, this.LD, 299);    makeDecodeTables(table, 299, this.DD, 60);    makeDecodeTables(table, 359, this.LDD, 17);    makeDecodeTables(table, 376, this.RD,       28);    for (int i = 0; i < this.unpOldTable.length; i++) {      this.unpOldTable[i] = table[i];    }    return true;  }  private boolean readVMCode()    throws IOException, RarException  {    int FirstByte = getbits() >> 8;    addbits(8);    int Length = (FirstByte & 0x7) + 1;    if (Length == 7) {      Length = (getbits() >> 8) + 7;      addbits(8);    } else if (Length == 8) {      Length = getbits();      addbits(16);    }    List vmCode = new ArrayList();    for (int I = 0; I < Length; I++) {      if ((this.inAddr >= this.readTop - 1) && (!unpReadBuf()) && (I < Length - 1)) {        return false;      }      vmCode.add(Byte.valueOf((byte)(getbits() >> 8)));      addbits(8);    }    return addVMCode(FirstByte, vmCode, Length);  }  private boolean readVMCodePPM() throws IOException, RarException  {    int FirstByte = this.ppm.decodeChar();    if (FirstByte == -1) {      return false;    }    int Length = (FirstByte & 0x7) + 1;    if (Length == 7) {      int B1 = this.ppm.decodeChar();      if (B1 == -1) {        return false;      }      Length = B1 + 7;    } else if (Length == 8) {      int B1 = this.ppm.decodeChar();      if (B1 == -1) {        return false;      }      int B2 = this.ppm.decodeChar();      if (B2 == -1) {        return false;      }      Length = B1 * 256 + B2;    }    List vmCode = new ArrayList();    for (int I = 0; I < Length; I++) {      int Ch = this.ppm.decodeChar();      if (Ch == -1) {        return false;      }      vmCode.add(Byte.valueOf((byte)Ch));    }    return addVMCode(FirstByte, vmCode, Length);  }protected DistDecode DD = new DistDecode();  protected LowDistDecode LDD = new LowDistDecode();  protected RepDecode RD = new RepDecode();  protected BitDecode BD = new BitDecode();  public static final int[] LDecode = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12,     14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192,     224 };  public static final byte[] LBits = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2,     2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5 };  public static final int[] DDecode = { 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32,     48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072,     4096, 6144, 8192, 12288, 16384, 24576, 32768, 49152, 65536, 98304,     131072, 196608, 262144, 327680, 393216, 458752, 524288, 589824,     655360, 720896, 786432, 851968, 917504, 983040 };  public static final int[] DBits = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5,     5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14,     15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 };  public static final int[] SDDecode = { 0, 4, 8, 16, 32, 64, 128, 192 };  public static final int[] SDBits = { 2, 2, 3, 4, 5, 6, 6, 6 };  protected void unpack20(boolean solid)    throws IOException, RarException  {    if (this.suspended) {      this.unpPtr = this.wrPtr;    } else {      unpInitData(solid);      if (!unpReadBuf()) {        return;      }      if ((!solid) &&         (!ReadTables20())) {        return;      }      this.destUnpSize -= 1L;    }    while (this.destUnpSize >= 0L) {      this.unpPtr &= 4194303;      if ((this.inAddr > this.readTop - 30) &&         (!unpReadBuf()))        break;      if (((this.wrPtr - this.unpPtr & 0x3FFFFF) < 270) &&         (this.wrPtr != this.unpPtr)) {        oldUnpWriteBuf();        if (this.suspended)          return;      }      if (this.UnpAudioBlock != 0) {        int AudioNumber = decodeNumber(this.MD[this.UnpCurChannel]);        if (AudioNumber == 256) {          if (!ReadTables20())            break;        }        else {          this.window[(this.unpPtr++)] = DecodeAudio(AudioNumber);          if (++this.UnpCurChannel == this.UnpChannels)            this.UnpCurChannel = 0;          this.destUnpSize -= 1L;        }      }      else {        int Number = decodeNumber(this.LD);        if (Number < 256) {          this.window[(this.unpPtr++)] = ((byte)Number);          this.destUnpSize -= 1L;        }        else if (Number > 269) {          Number -= 270; int Length = LDecode[Number] + 3;          int Bits;          if ((Bits = LBits[Number]) > 0) {            Length += (getbits() >>> 16 - Bits);            addbits(Bits);          }          int DistNumber = decodeNumber(this.DD);          int Distance = DDecode[DistNumber] + 1;          if ((Bits = DBits[DistNumber]) > 0) {            Distance += (getbits() >>> 16 - Bits);            addbits(Bits);          }          if (Distance >= 8192) {            Length++;            if (Distance >= 262144L) {              Length++;            }          }          CopyString20(Length, Distance);        }        else if (Number == 269) {          if (!ReadTables20()) {            break;          }        }        else if (Number == 256) {          CopyString20(this.lastLength, this.lastDist);        }        else if (Number < 261) {          int Distance = this.oldDist[(this.oldDistPtr - (Number - 256) & 0x3)];          int LengthNumber = decodeNumber(this.RD);          int Length = LDecode[LengthNumber] + 2;          int Bits;          if ((Bits = LBits[LengthNumber]) > 0) {            Length += (getbits() >>> 16 - Bits);            addbits(Bits);          }          if (Distance >= 257) {            Length++;            if (Distance >= 8192) {              Length++;              if (Distance >= 262144)                Length++;            }          }          CopyString20(Length, Distance);        }        else if (Number < 270) {          Number -= 261; int Distance = SDDecode[Number] + 1;          int Bits;          if ((Bits = SDBits[Number]) > 0) {            Distance += (getbits() >>> 16 - Bits);            addbits(Bits);          }          CopyString20(2, Distance);        }      }    }    ReadLastTables();    oldUnpWriteBuf();  }  protected void CopyString20(int Length, int Distance)  {    this.lastDist = (this.oldDist[(this.oldDistPtr++ & 0x3)] = Distance);    this.lastLength = Length;    this.destUnpSize -= Length;    int DestPtr = this.unpPtr - Distance;      (this.unpPtr < 4194004)) {        Length--;        this.window[(this.unpPtr++)] = this.window[(DestPtr++)];      }    } else {      while (Length-- != 0) {      this.window[this.unpPtr] = this.window[(DestPtr++ & 0x3FFFFF)];     this.unpPtr = (this.unpPtr + 1 & 0x3FFFFF);    }  }}public class UnsignedByte{  public static byte longToByte(long unsignedByte1)  {    return (byte)(int)(unsignedByte1 & 0xFF);  }  public static byte intToByte(int unsignedByte1) {    return (byte)(unsignedByte1 & 0xFF);  }  public static byte shortToByte(short unsignedByte1) {    return (byte)(unsignedByte1 & 0xFF);  }  public static short add(byte unsignedByte1, byte unsignedByte2)  {    return (short)(unsignedByte1 + unsignedByte2);  }  public static short sub(byte unsignedByte1, byte unsignedByte2)  {    return (short)(unsignedByte1 - unsignedByte2);  }  public static void main(String[] args)  {    System.out.println(add((byte)-2, (byte)1));    System.out.println(add((byte)-1, (byte)1));    System.out.println(add((byte)127, (byte)1));    System.out.println(add((byte)-1, (byte)-1));    System.out.println(sub((byte)-2, (byte)1));    System.out.println(sub((byte)0, (byte)1));    System.out.println(sub((byte)-128, (byte)1));    System.out.println(1);  }}