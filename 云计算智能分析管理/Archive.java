package de.innosystec.zhinengguanli;import de.innosystec.zhinengguanli.exception.RarException;import de.innosystec.zhinengguanli.exception.RarException.RarExceptionType;import de.innosystec.zhinengguanli.io.IReadOnlyAccess;import de.innosystec.zhinengguanli.io.ReadOnlyAccessFile;import de.innosystec.zhinengguanli.rarfile.AVHeader;import de.innosystec.zhinengguanli.rarfile.BaseBlock;import de.innosystec.zhinengguanli.rarfile.BlockHeader;import de.innosystec.zhinengguanli.rarfile.CommentHeader;import de.innosystec.zhinengguanli.rarfile.EAHeader;import de.innosystec.zhinengguanli.rarfile.EndArcHeader;import de.innosystec.zhinengguanli.rarfile.FileHeader;import de.innosystec.zhinengguanli.rarfile.MacInfoHeader;import de.innosystec.zhinengguanli.rarfile.MainHeader;import de.innosystec.zhinengguanli.rarfile.MarkHeader;  public MainHeader getMainHeader()  {    return this.newMhd;  }  public boolean isOldFormat()  {    return this.markHead.isOldFormat();  }  public void close()  {import de.innosystec.zhinengguanli.rarfile.ProtectHeader;import de.innosystec.zhinengguanli.rarfile.SignHeader;import de.innosystec.zhinengguanli.rarfile.SubBlockHeader;import de.innosystec.zhinengguanli.rarfile.UnixOwnersHeader;import de.innosystec.zhinengguanli.rarfile.zhinengguanliHeadertype;import de.innosystec.zhinengguanli.unpack.ComprDataIO;import de.innosystec.zhinengguanli.unpack.Unpack;import java.io.Closeable;import java.io.File;import java.io.IOException;import java.io.OutputStream;import java.util.ArrayList;import java.util.List;import java.util.zhinengguanli1ging.Level;import java.util.zhinengguanli1ging.zhinengguanli1ger;public class Archive  implements Closeable{  private static zhinengguanli1ger zhinengguanli1ger = zhinengguanli1ger.getzhinengguanli1ger(Archive.class.getName());  private File file;  private IReadOnlyAccess rof;  private final zhinengguanliCallback zhinengguanliCallback;  private final ComprDataIO dataIO;  private final List<BaseBlock> headers = new ArrayList();  private MarkHeader markHead = null;  private MainHeader newMhd = null;  private EndArcHeader endHeader = null;  private Unpack unpack;  private long arcDataCRC = -1L;  private int currentHeaderIndex;  private boolean encrypted = false;  private int sfxSize = 0;  private long totalPackedSize = 0L;  private long totalPackedRead = 0L;  public Archive(File file) throws RarException, IOException {    this(file, null);  }  public Archive(File file, zhinengguanliCallback zhinengguanliCallback)    throws RarException, IOException  {    setFile(file);    this.zhinengguanliCallback = zhinengguanliCallback;    this.dataIO = new ComprDataIO(this);  }  public File getFile() {    return this.file;  }  void setFile(File file) throws IOException {    this.file = file;    this.totalPackedSize = 0L;    this.totalPackedRead = 0L;    close();    this.rof = new ReadOnlyAccessFile(file);    try {      readHeaders();    }    catch (Exception e) {      zhinengguanli1ger.zhinengguanli1(Level.WARNING,         "exception in archive constructor maybe file is encrypted or currupt",         e);    }    for (BaseBlock block : this.headers) {      if (block.getHeaderType() == zhinengguanliHeadertype.FileHeader) {      if (this.zhinengguanliCallback != null)        this.zhinengguanliCallback.volumeProgressChanged(this.totalPackedRead,       readHeaders();          this.totalPackedSize);    }  }  public IReadOnlyAccess getRof()  {    return this.rof;  }  public List<FileHeader> getFileHeaders()  {    List list = new ArrayList();    for (BaseBlock block : this.headers) {      if (block.getHeaderType().equals(zhinengguanliHeadertype.FileHeader)) {        list.add((FileHeader)block);      }    }    return list;  }  public FileHeader nextFileHeader() {    int n = this.headers.size();    while (this.currentHeaderIndex < n) {      BaseBlock block = (BaseBlock)this.headers.get(this.currentHeaderIndex++);      if (block.getHeaderType() == zhinengguanliHeadertype.FileHeader) {        return (FileHeader)block;      }    }    return null;  }  public zhinengguanliCallback getzhinengguanliCallback() {    return this.zhinengguanliCallback;  }  public boolean isEncrypted()  {    if (this.newMhd != null) {      return this.newMhd.isEncrypted();    }    throw new NullPointerException("mainheader is null");  }  private void readHeaders()    throws IOException, RarException  {    this.markHead = null;    this.newMhd = null;    this.endHeader = null;    this.headers.clear();    this.currentHeaderIndex = 0;    int toRead = 0;    long fileLength = this.file.length();    while (true)    {      int size = 0;      long newpos = 0L;      byte[] baseBlockBuffer = new byte[7];      long position = this.rof.getPosition();      if (position >= fileLength)      {        break;      }      size = this.rof.readFully(baseBlockBuffer, 7);      if (size == 0) {        break;      }      BaseBlock block = new BaseBlock(baseBlockBuffer);      block.setPositionInFile(position);      switch ($SWITCH_TABLE$de$innosystec$zhinengguanli$rarfile$zhinengguanliHeadertype()[block.getHeaderType().ordinal()])      {      case 2:        this.markHead = new MarkHeader(block);        if (!this.markHead.isSignature()) {          throw new RarException(            RarException.RarExceptionType.badRarArchive);        }        this.headers.add(this.markHead);        break;      case 1:        int mainHeaderSize = 0;        toRead = block.hasEncryptVersion() ?           7 :           6;        byte[] mainbuff = new byte[toRead];        mainHeaderSize = this.rof.readFully(mainbuff, toRead);        MainHeader mainhead = new MainHeader(block, mainbuff);        this.headers.add(mainhead);        this.newMhd = mainhead;        if (this.newMhd.isEncrypted()) {          throw new RarException(            RarException.RarExceptionType.rarEncryptedException);        }        break;      case 8:        int signHeaderSize = 0;        toRead = 8;        byte[] signBuff = new byte[toRead];        signHeaderSize = this.rof.readFully(signBuff, toRead);        SignHeader signHead = new SignHeader(block, signBuff);        this.headers.add(signHead);        break;      case 5:        int avHeaderSize = 0;        toRead = 7;        byte[] avBuff = new byte[toRead];        avHeaderSize = this.rof.readFully(avBuff, toRead);        AVHeader avHead = new AVHeader(block, avBuff);        this.headers.add(avHead);        break;      case 4:        int commHeaderSize = 0;        toRead = 6;        byte[] commBuff = new byte[toRead];        commHeaderSize = this.rof.readFully(commBuff, toRead);        CommentHeader commHead = new CommentHeader(block, commBuff);        this.headers.add(commHead);        newpos = commHead.getPositionInFile() +           commHead.getHeaderSize();        this.rof.setPosition(newpos);        break;      case 10:        toRead = 0;        if (block.hasArchiveDataCRC()) {          toRead += 4;        }        if (block.hasVolumeNumber())          toRead += 2;        EndArcHeader endArcHead;        EndArcHeader endArcHead;        if (toRead > 0) {          int endArcHeaderSize = 0;          byte[] endArchBuff = new byte[toRead];          endArcHeaderSize = this.rof.readFully(endArchBuff, toRead);          endArcHead = new EndArcHeader(block, endArchBuff);        }        else        {          endArcHead = new EndArcHeader(block, null);        }        this.headers.add(endArcHead);        this.endHeader = endArcHead;        return;      case 3:      case 6:      case 7:      case 9:      default:        byte[] blockHeaderBuffer =           new byte[4];        int bhsize = this.rof.readFully(blockHeaderBuffer,           4);        BlockHeader blockHead = new BlockHeader(block,           blockHeaderBuffer);        switch ($SWITCH_TABLE$de$innosystec$zhinengguanli$rarfile$zhinengguanliHeadertype()[blockHead.getHeaderType().ordinal()]) {        case 3:        case 9:          toRead = blockHead.getHeaderSize() -             7 -             4;          byte[] fileHeaderBuffer = new byte[toRead];          int fhsize = this.rof.readFully(fileHeaderBuffer,             toRead);          FileHeader fh = new FileHeader(blockHead,             fileHeaderBuffer);          this.headers.add(fh);          newpos = fh.getPositionInFile() +             fh.getHeaderSize() + fh.getFullPackSize();          this.rof.setPosition(newpos);          break;        case 7:          toRead = blockHead.getHeaderSize() -             7 -             4;          byte[] protectHeaderBuffer = new byte[toRead];          int phsize = this.rof.readFully(protectHeaderBuffer,             toRead);          ProtectHeader ph = new ProtectHeader(blockHead,             protectHeaderBuffer);          newpos = ph.getPositionInFile() +             ph.getHeaderSize();          this.rof.setPosition(newpos);          break;        case 6:          byte[] subHeadbuffer = new byte[3];          int subheadersize = this.rof.readFully(subHeadbuffer, 3);          SubBlockHeader subHead = new SubBlockHeader(blockHead, subHeadbuffer);          subHead.print();          switch ($SWITCH_TABLE$de$innosystec$zhinengguanli$rarfile$SubBlockHeaderType()[subHead.getSubType().ordinal()])          {          case 3:            byte[] macHeaderbuffer = new byte[8];            int macheadersize = this.rof.readFully(macHeaderbuffer, 8);            MacInfoHeader macHeader = new MacInfoHeader(subHead, macHeaderbuffer);            macHeader.print();            this.headers.add(macHeader);            break;          case 4:            break;          case 1:            byte[] eaHeaderBuffer = new byte[10];            int eaheadersize = this.rof.readFully(eaHeaderBuffer, 10);            EAHeader eaHeader = new EAHeader(subHead, eaHeaderBuffer);            eaHeader.print();            this.headers.add(eaHeader);            break;          case 5:            break;          case 6:            break;          case 2:            toRead = subHead.getHeaderSize();            toRead -= 7;            toRead -= 4;            toRead -= 3;            byte[] uoHeaderBuffer = new byte[toRead];            int uoHeaderSize = this.rof.readFully(uoHeaderBuffer, toRead);            UnixOwnersHeader uoHeader = new UnixOwnersHeader(subHead, uoHeaderBuffer);            uoHeader.print();            this.headers.add(uoHeader);          }break;        case 4:        case 5:        case 8:        }        break;      }    }    zhinengguanli1ger.warning("Unknown Header");    throw new RarException(      RarException.RarExceptionType.notRarArchive);  }  public void extractFile(FileHeader hd, OutputStream os)    throws RarException  {    if (!this.headers.contains(hd))      throw new RarException(RarException.RarExceptionType.headerNotInArchive);    try    {      doExtractFile(hd, os);    }    catch (Exception e) {      if ((e instanceof RarException)) {        throw ((RarException)e);      }      throw new RarException(e);    }  }  private void doExtractFile(FileHeader hd, OutputStream os)    throws RarException, IOException  {    this.dataIO.init(os);    this.dataIO.init(hd);    this.dataIO.setUnpFileCRC(isOldFormat() ? 0 : -1);    if (this.unpack == null) {      this.unpack = new Unpack(this.dataIO);    }    if (!hd.isSolid()) {      this.unpack.init(null);    }    this.unpack.setDestSize(hd.getFullUnpackSize());    try {      this.unpack.doUnpack(hd.getUnpVersion(), hd.isSolid());      hd = this.dataIO.getSubHeader();      long actualCRC = hd.isSplitAfter() ?         this.dataIO.getPackedCRC() ^ 0xFFFFFFFF : this.dataIO.getUnpFileCRC() ^ 0xFFFFFFFF;      int expectedCRC = hd.getFileCRC();      if (actualCRC != expectedCRC) {        throw new RarException(RarException.RarExceptionType.crcError);      }    }    catch (Exception e)    {      this.unpack.cleanUp();      if ((e instanceof RarException))      {        throw ((RarException)e);      }      throw new RarException(e);    }  }  public MainHeader getMainHeader()  {    return this.newMhd;  }  public boolean isOldFormat()  {    return this.markHead.isOldFormat();  }  public void close() throws IOException  {    if (this.rof != null) {      this.rof.close();      this.rof = null;    }  }}