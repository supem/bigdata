package de.innosystec.zhinengguanli.unpack;import de.innosystec.zhinengguanli.Archive;import de.innosystec.zhinengguanli.Volume;import de.innosystec.zhinengguanli.crc.RarCRC;import de.innosystec.zhinengguanli.exception.RarException;import de.innosystec.zhinengguanli.io.ReadOnlyAccessInputStream;import de.innosystec.zhinengguanli.rarfile.FileHeader;import java.io.EOFException;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class ComprDataIO{  private final Archive archive;  private long unpPackedSize;  private boolean testMode;  private boolean skipUnpCRC;  private InputStream inputStream;  private OutputStream outputStream;  private FileHeader subHead;  private boolean packVolume;  private boolean unpVolume;  private boolean nextVolumeMissing;  private long totalPackRead;  private long unpArcSize;  private long curPackRead;  private long curPackWrite;  private long curUnpRead;  private long curUnpWrite;  private long processedArcSize;  private long totalArcSize;  private long packFileCRC;  private long unpFileCRC;  private long packedCRC;  private int encryption;  private int decryption;  private int lastPercent;  private char currentCommand;  public ComprDataIO(Archive arc)  {    this.archive = arc;  }  public void init(OutputStream outputStream) {    this.outputStream = outputStream;    this.unpPackedSize = 0L;    this.testMode = false;    this.skipUnpCRC = false;    this.packVolume = false;    this.unpVolume = false;    this.nextVolumeMissing = false;    this.encryption = 0;    this.decryption = 0;    this.totalPackRead = 0L;    this.curPackRead = (this.curPackWrite = this.curUnpRead = this.curUnpWrite = 0L);    this.packFileCRC = (this.unpFileCRC = this.packedCRC = -1L);    this.lastPercent = -1;    this.subHead = null;    this.currentCommand = '\000';    this.processedArcSize = (this.totalArcSize = 0L);  }  public void init(FileHeader hd) throws IOException {    long startPos = hd.getPositionInFile() + hd.getHeaderSize();    this.unpPackedSize = hd.getFullPackSize();    this.inputStream = new ReadOnlyAccessInputStream(      this.archive.getRof(),       startPos,       startPos + this.unpPackedSize);    this.subHead = hd;    this.curUnpRead = 0L;    this.curPackWrite = 0L;    this.packedCRC = -1L;  }  public int unpRead(byte[] addr, int offset, int count) throws IOException, RarException  {    int retCode = 0; int totalRead = 0;    while (count > 0) {      int readSize = count > this.unpPackedSize ? (int)this.unpPackedSize : count;      retCode = this.inputStream.read(addr, offset, readSize);      if (retCode < 0) {        throw new EOFException();      }      if (this.subHead.isSplitAfter()) {        this.packedCRC = RarCRC.checkCrc(          (int)this.packedCRC, addr, offset, retCode);      }      this.curUnpRead += retCode;      totalRead += retCode;      offset += retCode;      count -= retCode;      this.unpPackedSize -= retCode;      this.archive.bytesReadRead(retCode);      if ((this.unpPackedSize != 0L) || (!this.subHead.isSplitAfter())) break;      if (!Volume.mergeArchive(this.archive, this)) {        this.nextVolumeMissing = true;        return -1;      }    }    if (retCode != -1) {      retCode = totalRead;    }    return retCode;  }  public void unpWrite(byte[] addr, int offset, int count)    throws IOException  {    if (!this.testMode)    {      this.outputStream.write(addr, offset, count);    }    this.curUnpWrite += count;    if (!this.skipUnpCRC)      if (this.archive.isOldFormat()) {        this.unpFileCRC = RarCRC.checkOldCrc(          (short)(int)this.unpFileCRC, addr, count);      }      else        this.unpFileCRC = RarCRC.checkCrc(          (int)this.unpFileCRC, addr, offset, count);  }  public void setPackedSizeToRead(long size)  {    this.unpPackedSize = size;  }  public void setTestMode(boolean mode)  {    this.testMode = mode;  }  protected void unpInitData(boolean solid) {    if (!solid) {      this.tablesRead = false;      Arrays.fill(this.oldDist, 0);      this.oldDistPtr = 0;      this.lastDist = 0;      this.lastLength = 0;      Arrays.fill(this.unpOldTable, (byte)0);      this.unpPtr = 0;      this.wrPtr = 0;      this.ppmEscChar = 2;      initFilters();    }    InitBitInput();    this.ppmError = false;    this.writtenFileSize = 0L;    this.readTop = 0;    this.readBorder = 0;    unpInitData20(solid);  }  private void initFilters()  {    this.oldFilterLengths.clear();    this.lastFilter = 0;    this.filters.clear();    this.prgStack.clear();  } public long getCurPackRead()  {    return this.curPackRead;  } protected void makeDecodeTables(byte[] lenTab, int offset, Decode dec, int size)  {    int[] lenCount = new int[16];    int[] tmpPos = new int[16];    Arrays.fill(lenCount, 0);    Arrays.fill(dec.getDecodeNum(), 0);    for (int i = 0; i < size; i++) {      lenCount[(lenTab[(offset + i)] & 0xF)] += 1;    }    lenCount[0] = 0;    tmpPos[0] = 0; dec.getDecodePos()[0] = 0; dec.getDecodeLen()[0] = 0; long N = 0L; for (i = 1; i < 16; i++) {      N = 2L * (N + lenCount[i]);      long M = N << 15 - i;      if (M > 65535L) {        M = 65535L;      }      dec.getDecodeLen()[i] = ((int)M);      int tmp167_166 = (dec.getDecodePos()[(i - 1)] +         lenCount[(i - 1)]);      dec.getDecodePos()[i] =         tmp167_166;      tmpPos[i] =         tmp167_166;    }    for (i = 0; i < size; i++) {      if (lenTab[(offset + i)] != 0)      {        byte tmp210_209 = (lenTab[(offset + i)] & 0xF);        int[] tmp210_199 = tmpPos;        int tmp212_211 = tmp210_199[tmp210_209]; tmp210_199[tmp210_209] = (tmp212_211 + 1); dec.getDecodeNum()[tmp212_211] = i;      }    }    dec.setMaxNum(size);  }  protected int decodeNumber(Decode dec)  {    long bitField = getbits() & 0xFFFE;    int[] decodeLen = dec.getDecodeLen();    int bits;    int bits;    if (bitField < decodeLen[8])    {      int bits;      if (bitField < decodeLen[4])      {        int bits;        if (bitField < decodeLen[2])        {          int bits;          if (bitField < decodeLen[1])            bits = 1;          else            bits = 2;        }        else        {          int bits;          if (bitField < decodeLen[3])            bits = 3;          else            bits = 4;        }      }      else      {        int bits;        if (bitField < decodeLen[6])        {          int bits;          if (bitField < decodeLen[5])            bits = 5;          else            bits = 6;        }        else        {          int bits;          if (bitField < decodeLen[7])            bits = 7;          else            bits = 8;        }      }    }    else    {      int bits;      if (bitField < decodeLen[12])      {        int bits;        if (bitField < decodeLen[10])        {          int bits;          if (bitField < decodeLen[9])            bits = 9;          else            bits = 10;        }        else        {          int bits;          if (bitField < decodeLen[11])            bits = 11;          else            bits = 12;        }      }      else      {        int bits;        if (bitField < decodeLen[14])        {          int bits;          if (bitField < decodeLen[13])            bits = 13;          else            bits = 14;        }        else {          bits = 15;        }      }    }    addbits(bits);    int N = dec.getDecodePos()[bits] + (      (int)bitField - decodeLen[(bits - 1)] >>> 16 - bits);    if (N >= dec.getMaxNum()) {      N = 0;    }    return dec.getDecodeNum()[N];  }  public boolean isFileExtracted()  {    return this.fileExtracted;  }  protected int decodeNum(int Num, int StartPos, int[] DecTab, int[] PosTab)  {    Num &= 65520; for (int I = 0; DecTab[I] <= Num; I++) {      StartPos++;    }    faddbits(StartPos);    return (Num - (I != 0 ? DecTab[(I - 1)] : 0) >>> 16 - StartPos) + PosTab[StartPos];  }  protected void oldUnpWriteBuf() throws IOException  {    if (this.unpPtr != this.wrPtr) {      this.unpSomeRead = true;    }    if (this.unpPtr < this.wrPtr) {      this.unpIO.unpWrite(this.window, this.wrPtr, -this.wrPtr & 0x3FFFFF);      this.unpIO.unpWrite(this.window, 0, this.unpPtr);      this.unpAllBuf = true;    } else {      this.unpIO.unpWrite(this.window, this.wrPtr, this.unpPtr - this.wrPtr);    }    this.wrPtr = this.unpPtr;  }}