package de.innosystec.zhinengguanli.unsigned;import java.io.PrintStream;public abstract class Unpack15 extends BitInput{  protected int readBorder;  protected boolean suspended;  protected boolean unpAllBuf;  protected ComprDataIO unpIO;  protected boolean unpSomeRead;  protected int readTop;  protected long destUnpSize;  protected byte[] window;  protected int[] oldDist = new int[4];  protected int unpPtr;  protected int wrPtr;  protected int oldDistPtr;  protected int[] ChSet = new int[256]; protected int[] ChSetA = new int[256];  protected int[] ChSetB = new int[256]; protected int[] ChSetC = new int[256];  protected int[] Place = new int[256]; protected int[] PlaceA = new int[256];  protected int[] PlaceB = new int[256]; protected int[] PlaceC = new int[256];  protected int[] NToPl = new int[256]; protected int[] NToPlB = new int[256];  protected int[] NToPlC = new int[256];  protected int FlagBuf;  protected int AvrPlc;  protected int AvrPlcB;  protected int AvrLn1;  protected int AvrLn2;  protected int AvrLn3;  protected int Buf60;  protected int NumHuf;  protected int StMode;  protected int LCount;  protected int FlagsCnt;  protected int Nhfb;  protected int Nlzb;  protected int MaxDist3;  protected int lastDist;  protected int lastLength;  private static final int STARTL1 = 2;  private static int[] DecL1 = { 32768, 40960, 49152, 53248, 57344,     59904, 60928, 61440, 61952, 61952, 65535 };  private static int[] PosL1 = { 0, 0, 0, 2, 3, 5, 7, 11, 16, 20, 24, 32, 32 };  private static final int STARTL2 = 3;  private static int[] DecL2 = { 40960, 49152, 53248, 57344, 59904,     60928, 61440, 61952, 62016, 65535 };  private static int[] PosL2 = { 0, 0, 0, 0, 5, 7, 9, 13, 18, 22, 26, 34, 36 };  private static final int STARTHF0 = 4;  private static int[] DecHf0 = { 32768, 49152, 57344, 61952, 61952,     61952, 61952, 61952, 65535 };  private static int[] PosHf0 = { 0, 0, 0, 0, 0, 8, 16, 24, 33, 33, 33, 33,     33 };  private static final int STARTHF1 = 5;  private static int[] DecHf1 = { 8192, 49152, 57344, 61440, 61952,     61952, 63456, 65535 };  private static int[] PosHf1 = { 0, 0, 0, 0, 0, 0, 4, 44, 60, 76, 80, 80,     127 };  private static final int STARTHF2 = 5;  private static int[] DecHf2 = { 4096, 9216, 32768, 49152, 64000,     65535, 65535, 65535 };  private static int[] PosHf2 = { 0, 0, 0, 0, 0, 0, 2, 7, 53, 117, 233 };  private static final int STARTHF3 = 6;  private static int[] DecHf3 = { 2048, 9216, 60928, 65152, 65535,     65535, 65535 };  private static int[] PosHf3 = { 0, 0, 0, 0, 0, 0, 0, 2, 16, 218, 251 };  private static final int STARTHF4 = 8;  private static int[] DecHf4 = { 65280, 65535, 65535, 65535, 65535,     65535 };  private static int[] PosHf4 = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 255 };  static int[] ShortLen1 = { 1, 3, 4, 4, 5, 6, 7, 8, 8, 4, 4, 5, 6, 6, 4 };  static int[] ShortXor1 = { 0, 160, 208, 224, 240, 248, 252, 254,     255, 192, 128, 144, 152, 156, 176 };  static int[] ShortLen2 = { 2, 3, 3, 3, 4, 4, 5, 6, 6, 4, 4, 5, 6, 6, 4 };  static int[] ShortXor2 = { 0, 64, 96, 160, 208, 224, 240, 248,     252, 192, 128, 144, 152, 156, 176 };  protected abstract void unpInitData(boolean paramBoolean);  protected void unpack15(boolean solid)    throws IOException, RarException  {    if (this.suspended) {      this.unpPtr = this.wrPtr;    } else {      unpInitData(solid);      oldUnpInitData(solid);      unpReadBuf();      if (!solid) {        initHuff();        this.unpPtr = 0;      } else {        this.unpPtr = this.wrPtr;      }      this.destUnpSize -= 1L;    }    if (this.destUnpSize >= 0L) {      getFlagsBuf();      this.FlagsCnt = 8;    }    while (this.destUnpSize >= 0L) {      this.unpPtr &= 4194303;      if ((this.inAddr > this.readTop - 30) && (!unpReadBuf())) {        break;      }      if (((this.wrPtr - this.unpPtr & 0x3FFFFF) < 270) &&         (this.wrPtr != this.unpPtr)) {        oldUnpWriteBuf();        if (this.suspended) {          return;        }      }      if (this.StMode != 0) {        huffDecode();      }      else      {        if (--this.FlagsCnt < 0) {          getFlagsBuf();          this.FlagsCnt = 7;        }        if ((this.FlagBuf & 0x80) != 0) {          this.FlagBuf <<= 1;          if (this.Nlzb > this.Nhfb)            longLZ();          else            huffDecode();        }        else {          this.FlagBuf <<= 1;          if (--this.FlagsCnt < 0) {            getFlagsBuf();            this.FlagsCnt = 7;          }          if ((this.FlagBuf & 0x80) != 0) {            this.FlagBuf <<= 1;            if (this.Nlzb > this.Nhfb)              huffDecode();            else              longLZ();          }          else {            this.FlagBuf <<= 1;            shortLZ();          }        }      }    }    oldUnpWriteBuf();  }  protected boolean unpReadBuf()    throws IOException, RarException  {    int dataSize = this.readTop - this.inAddr;    if (dataSize < 0) {      return false;    }    if (this.inAddr > 16384) {      if (dataSize > 0)      {        System.arraycopy(this.inBuf, this.inAddr, this.inBuf, 0, dataSize);      }      this.inAddr = 0;      this.readTop = dataSize;    }    else {      dataSize = this.readTop;    }    int readCode = this.unpIO.unpRead(this.inBuf, dataSize, 32768 - dataSize & 0xFFFFFFF0);    if (readCode > 0) {      this.readTop += readCode;    }    this.readBorder = (this.readTop - 30);    return readCode != -1;  }  private int getShortLen1(int pos)  {    return pos == 1 ? this.Buf60 + 3 : ShortLen1[pos];  }  private int getShortLen2(int pos)  {    return pos == 3 ? this.Buf60 + 3 : ShortLen2[pos];  }  protected void shortLZ()  {    this.NumHuf = 0;    int BitField = fgetbits();    if (this.LCount == 2) {      faddbits(1);      if (BitField >= 32768) {        oldCopyString(this.lastDist, this.lastLength);        return;      }      BitField <<= 1;      this.LCount = 0;    }    BitField >>>= 8;    int Length;    if (this.AvrLn1 < 37) {      int Length = 0;      while (((BitField ^ ShortXor1[Length]) & (255 >>> getShortLen1(Length) ^ 0xFFFFFFFF)) != 0) {        Length++;      }      faddbits(getShortLen1(Length));    } else {      Length = 0;      while (((BitField ^ ShortXor2[Length]) & (255 >> getShortLen2(Length) ^ 0xFFFFFFFF)) != 0) {        Length++;      }      faddbits(getShortLen2(Length));    }    if (Length >= 9) {      if (Length == 9) {        this.LCount += 1;        oldCopyString(this.lastDist, this.lastLength);        return;      }      if (Length == 14) {        this.LCount = 0;        Length = decodeNum(fgetbits(), 3, DecL2, PosL2) + 5;        int Distance = fgetbits() >> 1 | 0x8000;        faddbits(15);        this.lastLength = Length;        this.lastDist = Distance;        oldCopyString(Distance, Length);        return;      }      this.LCount = 0;      int SaveLength = Length;      int Distance = this.oldDist[(this.oldDistPtr - (Length - 9) & 0x3)];      Length = decodeNum(fgetbits(), 2, DecL1, PosL1) + 2;      if ((Length == 257) && (SaveLength == 10)) {        this.Buf60 ^= 1;        return;      }      if (Distance > 256)        Length++;      if (Distance >= this.MaxDist3) {        Length++;      }      this.oldDist[(this.oldDistPtr++)] = Distance;      this.oldDistPtr &= 3;      this.lastLength = Length;      this.lastDist = Distance;      oldCopyString(Distance, Length);      return;    }    this.LCount = 0;    this.AvrLn1 += Length;    this.AvrLn1 -= (this.AvrLn1 >> 4);    int DistancePlace = decodeNum(fgetbits(), 5, DecHf2, PosHf2) & 0xFF;    int Distance = this.ChSetA[DistancePlace];    DistancePlace--; if (DistancePlace != -1) {      this.PlaceA[Distance] -= 1;      int LastDistance = this.ChSetA[DistancePlace];      this.PlaceA[LastDistance] += 1;      this.ChSetA[(DistancePlace + 1)] = LastDistance;      this.ChSetA[DistancePlace] = Distance;    }    Length += 2;    this.oldDist[(this.oldDistPtr++)] = (++Distance);    this.oldDistPtr &= 3;    this.lastLength = Length;    this.lastDist = Distance;    oldCopyString(Distance, Length);  }  protected void longLZ()  {    this.NumHuf = 0;    this.Nlzb += 16;    if (this.Nlzb > 255) {      this.Nlzb = 144;      this.Nhfb >>>= 1;    }    int OldAvr2 = this.AvrLn2;    int BitField = fgetbits();    int Length;    int Length;    if (this.AvrLn2 >= 122) {      Length = decodeNum(BitField, 3, DecL2, PosL2);    }    else    {      int Length;      if (this.AvrLn2 >= 64) {        Length = decodeNum(BitField, 2, DecL1, PosL1);      }      else if (BitField < 256) {        int Length = BitField;        faddbits(16);     for (Length = 0; (BitField << Length & 0x8000) == 0; Length++);    faddbits(Length + 1);  }} protected void ReadLastTables() throws IOException, RarException  {    if (this.readTop >= this.inAddr + 5)      if (this.UnpAudioBlock != 0) {        if (decodeNumber(this.MD[this.UnpCurChannel]) == 256) {          ReadTables20();        }      }      else if (decodeNumber(this.LD) == 269)        ReadTables20();  }  protected byte DecodeAudio(int Delta)  {    AudioVariables v = this.AudV[this.UnpCurChannel];    v.setByteCount(v.getByteCount() + 1);    v.setD4(v.getD3());    v.setD3(v.getD2());    v.setD2(v.getLastDelta() - v.getD1());    v.setD1(v.getLastDelta());    int PCh = 8 * v.getLastChar() + v.getK1() * v.getD1();    PCh += v.getK2() * v.getD2() + v.getK3() * v.getD3();    PCh += v.getK4() * v.getD4() + v.getK5() * this.UnpChannelDelta;    PCh = PCh >>> 3 & 0xFF;    int Ch = PCh - Delta;    int D = (byte)Delta << 3;    v.getDif()[0] += Math.abs(D);    v.getDif()[1] += Math.abs(D - v.getD1());    v.getDif()[2] += Math.abs(D + v.getD1());    v.getDif()[3] += Math.abs(D - v.getD2());    v.getDif()[4] += Math.abs(D + v.getD2());    v.getDif()[5] += Math.abs(D - v.getD3());    v.getDif()[6] += Math.abs(D + v.getD3());    v.getDif()[7] += Math.abs(D - v.getD4());    v.getDif()[8] += Math.abs(D + v.getD4());    v.getDif()[9] += Math.abs(D - this.UnpChannelDelta);    v.getDif()[10] += Math.abs(D + this.UnpChannelDelta);    v.setLastDelta((byte)(Ch - v.getLastChar()));    this.UnpChannelDelta = v.getLastDelta();    v.setLastChar(Ch);    if ((v.getByteCount() & 0x1F) == 0) {      int MinDif = v.getDif()[0]; int NumMinDif = 0;      v.getDif()[0] = 0;      for (int I = 1; I < v.getDif().length; I++) {        if (v.getDif()[I] < MinDif) {          MinDif = v.getDif()[I];          NumMinDif = I;        }        v.getDif()[I] = 0;      }      switch (NumMinDif) {      case 1:        if (v.getK1() >= -16) {          v.setK1(v.getK1() - 1);        }        break;      case 2:        if (v.getK1() < 16) {          v.setK1(v.getK1() + 1);        }        break;      case 3:        if (v.getK2() >= -16) {          v.setK2(v.getK2() - 1);        }        break;      case 4:        if (v.getK2() < 16) {          v.setK2(v.getK2() + 1);        }        break;      case 5:        if (v.getK3() >= -16) {          v.setK3(v.getK3() - 1);        }        break;      case 6:        if (v.getK3() < 16) {          v.setK3(v.getK3() + 1);        }        break;      case 7:        if (v.getK4() >= -16) {          v.setK4(v.getK4() - 1);        }        break;      case 8:        if (v.getK4() < 16) {          v.setK4(v.getK4() + 1);        }        break;      case 9:        if (v.getK5() >= -16) {          v.setK5(v.getK5() - 1);        }        break;      case 10:        if (v.getK5() < 16) {          v.setK5(v.getK5() + 1);1);    pc.setAddress(this.maxContext.getAddress());    for (; pc.getAddress() != this.minContext.getAddress();       pc.setAddress(pc.getSuffix()))    {      int ns1;      if ((ns1 = pc.getNumStats()) != 1) {        if ((ns1 & 0x1) == 0)        {          pc.getFreqData().setStats(            this.subAlloc.expandUnits(pc.getFreqData().getStats(),             ns1 >>> 1));          if (pc.getFreqData().getStats() == 0) {            updateModelRestart();            return;          }        }        int sum = (2 * ns1 < ns ? 1 : 0) + 2 * (          (4 * ns1 <= ns ? 1 : 0) & (          pc.getFreqData().getSummFreq() <= 8 * ns1 ? 1 : 0));        pc.getFreqData().incSummFreq(sum);      }      else {        p.setAddress(this.subAlloc.allocUnits(1));        if (p.getAddress() == 0) {          updateModelRestart();          return;        }        p.setValues(pc.getOneState());        pc.getFreqData().setStats(p);        if (p.getFreq() < 30) {          p.incFreq(p.getFreq());        }        else {          p.setFreq(120);        }        pc.getFreqData().setSummFreq(          p.getFreq() + this.initEsc + (ns > 3 ? 1 : 0));      }      int cf = 2 * fs.getFreq() * (pc.getFreqData().getSummFreq() + 6);      int sf = s0 + pc.getFreqData().getSummFreq();      if (cf < 6 * sf) {        cf = 1 + (cf > sf ? 1 : 0) + (cf >= 4 * sf ? 1 : 0);        pc.getFreqData().incSummFreq(3);    buffer.append("\n  foundState=");    buffer.append(this.runLength);    buffer.append("\n  initRL=");    buffer.append(this.initRL);    buffer.append("\n  coder=");    buffer.append("\n  runLength=");      }      else {        cf = 4 + (cf >= 9 * sf ? 1 : 0) + (cf >= 12 * sf ? 1 : 0) + (          cf >= 15 * sf ? 1 : 0);        pc.getFreqData().incSummFreq(cf);      }      p.setAddress(pc.getFreqData().getStats() + ns1 * 6);      p.setSuccessor(successor);      p.setSymbol(fs.getSymbol());      p.setFreq(cf);      pc.setNumStats(++ns1);    }    int address = fs.getSuccessor();    this.maxContext.setAddress(address);    this.minContext.setAddress(address);  }  public String toString()  {    StringBuilder buffer = new StringBuilder();    buffer.append("ModelPPM[");    buffer.append("\n  numMasked=");    buffer.append(this.numMasked);    buffer.append(this.orderFall);    buffer.append("\n  maxOrder=");buffer.append(this.maxOrder);    buffer.append("\n  foundState=");    buffer.append(this.runLength);    buffer.append("\n  initRL=");    buffer.append(this.initRL);    buffer.append(this.runLength);    buffer.append("\n  initRL=");    buffer.append(this.initRL);    buffer.append("\n  escCount=");buffer.append(this.escCount);        return;        }        p.setValues(pc.getOneState());        pc.getFreqData().setStats(p);        if (p.getFreq() < 30) {          p.incFreq(p.getFreq());        }        else {          p.setFreq(120);    buffer.append(this.runLength);    buffer.append("\n  initRL=");    buffer.append(this.initRL);    buffer.append("\n  coder=");  }}private void UnpWriteBuf()    throws IOException  {    int WrittenBorder = this.wrPtr;    int WriteSize = this.unpPtr - WrittenBorder & 0x3FFFFF;    for (int I = 0; I < this.prgStack.size(); I++) {      UnpackFilter flt = (UnpackFilter)this.prgStack.get(I);      if (flt != null)      {        if (flt.isNextWindow()) {          flt.setNextWindow(false);        }        else {          int BlockStart = flt.getBlockStart();          int BlockLength = flt.getBlockLength();          if ((BlockStart - WrittenBorder & 0x3FFFFF) < WriteSize) {            if (WrittenBorder != BlockStart) {              UnpWriteArea(WrittenBorder, BlockStart);              WrittenBorder = BlockStart;              WriteSize = this.unpPtr - WrittenBorder & 0x3FFFFF;            }            if (BlockLength <= WriteSize) {              int BlockEnd = BlockStart + BlockLength &                 0x3FFFFF;              if ((BlockStart < BlockEnd) || (BlockEnd == 0))              {                this.rarVM.setMemory(0, this.window, BlockStart, BlockLength);              } else {                int FirstPartLength = 4194304 - BlockStart;                this.rarVM.setMemory(0, this.window, BlockStart, FirstPartLength);                this.rarVM.setMemory(FirstPartLength, this.window, 0, BlockEnd);              }              VMPreparedProgram ParentPrg = ((UnpackFilter)this.filters.get(                flt.getParentFilter())).getPrg();              VMPreparedProgram Prg = flt.getPrg();              if (ParentPrg.getGlobalData().size() > 64)              {                Prg.getGlobalData().setSize(                  ParentPrg.getGlobalData().size());                for (int i = 0; i < ParentPrg.getGlobalData().size() -                   64; i++) {                  Prg.getGlobalData().set(                    64 + i,                     (Byte)ParentPrg.getGlobalData().get(                    64 + i));                }              }              ExecuteCode(Prg);              if (Prg.getGlobalData().size() > 64)              {                if (ParentPrg.getGlobalData().size() <                   Prg.getGlobalData().size()) {                  ParentPrg.getGlobalData().setSize(                    Prg.getGlobalData().size());                }                for (int i = 0; i < Prg.getGlobalData().size() -                   64; i++)                  ParentPrg.getGlobalData().set(                    64 + i,                     (Byte)Prg.getGlobalData().get(                    64 + i));              }              else {                ParentPrg.getGlobalData().clear();              }              int FilteredDataOffset = Prg.getFilteredDataOffset();              int FilteredDataSize = Prg.getFilteredDataSize();              byte[] FilteredData = new byte[FilteredDataSize];              for (int i = 0; i < FilteredDataSize; i++) {                FilteredData[i] = this.rarVM.getMem()[(FilteredDataOffset + i)];              }              this.prgStack.set(I, null);              while (I + 1 < this.prgStack.size()) {                UnpackFilter NextFilter = (UnpackFilter)this.prgStack.get(I + 1);                if ((NextFilter == null) ||                   (NextFilter.getBlockStart() != BlockStart) ||                   (NextFilter.getBlockLength() != FilteredDataSize) ||                   (NextFilter.isNextWindow()))                {                  break;                }                this.rarVM.setMemory(0, FilteredData, 0, FilteredDataSize);                VMPreparedProgram pPrg = ((UnpackFilter)this.filters.get(                  NextFilter.getParentFilter())).getPrg();                VMPreparedProgram NextPrg = NextFilter.getPrg();                if (pPrg.getGlobalData().size() > 64)                {                  NextPrg.getGlobalData().setSize(                    pPrg.getGlobalData().size());                  for (int i = 0; i < pPrg.getGlobalData().size() -                     64; i++) {                    NextPrg.getGlobalData().set(                      64 + i,                       (Byte)pPrg.getGlobalData().get(                      64 + i));                  }                }                ExecuteCode(NextPrg);                if (NextPrg.getGlobalData().size() > 64)                {                  if (pPrg.getGlobalData().size() <                     NextPrg.getGlobalData().size()) {                    pPrg.getGlobalData().setSize(                      NextPrg.getGlobalData().size());                  }                  for (int i = 0; i < NextPrg.getGlobalData().size() -                     64; i++)                    pPrg.getGlobalData().set(                      64 + i,                       (Byte)NextPrg.getGlobalData().get(                      64 + i));                }                else {                  pPrg.getGlobalData().clear();                }                FilteredDataOffset = NextPrg.getFilteredDataOffset();                FilteredDataSize = NextPrg.getFilteredDataSize();                FilteredData = new byte[FilteredDataSize];                for (int i = 0; i < FilteredDataSize; i++) {                  FilteredData[i] =                     ((Byte)NextPrg.getGlobalData()                    .get(FilteredDataOffset + i)).byteValue();                }                I++;                this.prgStack.set(I, null);              }              this.unpIO.unpWrite(FilteredData, 0, FilteredDataSize);              this.unpSomeRead = true;              this.writtenFileSize += FilteredDataSize;              WrittenBorder = BlockEnd;              WriteSize = this.unpPtr - WrittenBorder & 0x3FFFFF;            } else {              for (int J = I; J < this.prgStack.size(); J++) {                UnpackFilter filt = (UnpackFilter)this.prgStack.get(J);                if ((filt != null) && (filt.isNextWindow())) {                  filt.setNextWindow(false);                }              }              this.wrPtr = WrittenBorder;              return;            }          }        }      }    }    UnpWriteArea(WrittenBorder, this.unpPtr);    this.wrPtr = this.unpPtr;  }}  private void UnpWriteArea(int startPtr, int endPtr)    throws IOException  {    if (endPtr != startPtr) {      this.unpSomeRead = true;    }    if (endPtr < startPtr) {      UnpWriteData(this.window, startPtr, -startPtr & 0x3FFFFF);      UnpWriteData(this.window, 0, endPtr);      this.unpAllBuf = true;    } else {    UnpWriteData(this.window, startPtr, endPtr - startPtr);  }}private void insertLastMatch(int length, int distance)  {    this.lastDist = distance;    this.lastLength = length;  } public void setSkipUnpCRC(boolean skip)  {    this.skipUnpCRC = skip;  }  public void setSubHeader(FileHeader hd)  {    this.subHead = hd;  }  public long getCurPackRead()  {    return this.curPackRead;  }  public void setCurPackRead(long curPackRead)  {    this.curPackRead = curPackRead;  }  public long getCurPackWrite()  {    return this.curPackWrite;  }  public void setCurPackWrite(long curPackWrite)  {    this.curPackWrite = curPackWrite;  }  public long getCurUnpRead()  {    return this.curUnpRead;  }  public void setCurUnpRead(long curUnpRead)  {    this.curUnpRead = curUnpRead;  }  public long getCurUnpWrite()  {    return this.curUnpWrite;  }  public void setCurUnpWrite(long curUnpWrite)  {    this.curUnpWrite = curUnpWrite;  }  public int getDecryption()  {    return this.decryption;  }  public void setDecryption(int decryption)  {    this.decryption = decryption;  }  public int getEncryption()  {    return this.encryption;  }  public void setEncryption(int encryption)  {    this.encryption = encryption;  }  public boolean isNextVolumeMissing()  {    return this.nextVolumeMissing;  }  public void setNextVolumeMissing(boolean nextVolumeMissing)  {    this.nextVolumeMissing = nextVolumeMissing;  }  public long getPackedCRC() {    return this.packedCRC;  }  public void setPackedCRC(long packedCRC) {    this.packedCRC = packedCRC;  }  public long getPackFileCRC()  {    return this.packFileCRC;  }  public void setPackFileCRC(long packFileCRC)  {    this.packFileCRC = packFileCRC;  }  public boolean isPackVolume()  {    return this.packVolume;  }  public void setPackVolume(boolean packVolume)  {    this.packVolume = packVolume;  }  public long getProcessedArcSize()  {    return this.processedArcSize;  }  public void setProcessedArcSize(long processedArcSize)  {    this.processedArcSize = processedArcSize;  }  public long getTotalArcSize()  {    return this.totalArcSize;  }  public void setTotalArcSize(long totalArcSize)  {    this.totalArcSize = totalArcSize;  }  public long getTotalPackRead()  {    return this.totalPackRead;  }  public void setTotalPackRead(long totalPackRead)  {    this.totalPackRead = totalPackRead;  }  public long getUnpArcSize()  {    return this.unpArcSize;  }  public void setUnpArcSize(long unpArcSize)  {    this.unpArcSize = unpArcSize;  }  public long getUnpFileCRC()  {    return this.unpFileCRC;  }  public void setUnpFileCRC(long unpFileCRC)  {    this.unpFileCRC = unpFileCRC;  }  public boolean isUnpVolume()  {    return this.unpVolume;  }  public void setUnpVolume(boolean unpVolume)  {    this.unpVolume = unpVolume;  }  public FileHeader getSubHeader()  {    return this.subHead;  }}