package de.innosystec.xinxichaxun.unpack;import de.innosystec.xinxichaxun.Archive;import de.innosystec.xinxichaxun.Volume;import de.innosystec.xinxichaxun.crc.RarCRC;import de.innosystec.xinxichaxun.exception.RarException;import de.innosystec.xinxichaxun.io.ReadOnlyAccessInputStream;import de.innosystec.xinxichaxun.rarfile.FileHeader;import java.io.EOFException;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class ComprDataIO{  private final Archive archive;  private long unpPackedSize;  private boolean testMode;  private boolean skipUnpCRC;  private InputStream inputStream;  private OutputStream outputStream;  private FileHeader subHead;  private boolean packVolume;    else    {      int bits;      if (bitField < decodeLen[12])      {        int bits;        if (bitField < decodeLen[10])        {          int bits;          if (bitField < decodeLen[9])            bits = 9;          else            bits = 10;        }        else        {          int bits;          if (bitField < decodeLen[11])            bits = 11;          else            bits = 12;        else {          bits = 15;        }      }    }    addbits(bits);    int N = dec.getDecodePos()[bits] + (      (int)bitField - decodeLen[(bits - 1)] >>> 16 - bits);    if (N >= dec.getMaxNum()) {      N = 0;    }    return dec.getDecodeNum()[N];  }  protected boolean ReadTables20() throws IOException, RarException  {    byte[] BitLength = new byte[19];    byte[] Table = new byte[1028];    if ((this.inAddr > this.readTop - 25) &&       (!unpReadBuf())) {      return false;    }    int BitField = getbits();    this.UnpAudioBlock = (BitField & 0x8000);    if ((BitField & 0x4000) == 0)    {      Arrays.fill(this.UnpOldTable20, (byte)0);    }    addbits(2);    int TableSize;    int TableSize;    if (this.UnpAudioBlock != 0) {      this.UnpChannels = ((BitField >>> 12 & 0x3) + 1);      if (this.UnpCurChannel >= this.UnpChannels) {        this.UnpCurChannel = 0;      }      addbits(2);      TableSize = 257 * this.UnpChannels;    } else {      TableSize = 374;    }    for (int I = 0; I < 19; I++) {      BitLength[I] = ((byte)(getbits() >>> 12));      addbits(4);    }    makeDecodeTables(BitLength, 0, this.BD, 19);    I = 0;    while (I < TableSize) {      if ((this.inAddr > this.readTop - 5) &&         (!unpReadBuf())) {        return false;      }      int Number = decodeNumber(this.BD);      if (Number < 16) {        Table[I] = ((byte)(Number + this.UnpOldTable20[I] & 0xF));        I++;      } else if (Number == 16) {        int N = (getbits() >>> 14) + 3;        addbits(2);        do {          Table[I] = Table[(I - 1)];          I++;          if (N-- <= 0) break;  } while (I < TableSize);      }      else      {        int N;        if (Number == 17) {          int N = (getbits() >>> 13) + 3;          addbits(3);        } else {          N = (getbits() >>> 9) + 11;          addbits(7);        }        while ((N-- > 0) && (I < TableSize))          Table[(I++)] = 0;      }    }    if (this.inAddr > this.readTop) {      return true;    }    if (this.UnpAudioBlock != 0) {      for (I = 0; I < this.UnpChannels; I++)        makeDecodeTables(Table, I * 257, this.MD[I], 257);    } else {      makeDecodeTables(Table, 0, this.LD, 298);      makeDecodeTables(Table, 298, this.DD, 48);      makeDecodeTables(Table, 346, this.RD,         28);    }    for (int i = 0; i < this.UnpOldTable20.length; i++) {      this.UnpOldTable20[i] = Table[i];    }    return true;      }    }    UnpWriteArea(WrittenBorder, this.unpPtr);    this.wrPtr = this.unpPtr;  }  private void UnpWriteArea(int startPtr, int endPtr)    throws IOException  {    if (endPtr != startPtr) {      this.unpSomeRead = true;    }    if (endPtr < startPtr) {      UnpWriteData(this.window, startPtr, -startPtr & 0x3FFFFF);      UnpWriteData(this.window, 0, endPtr);      this.unpAllBuf = true;    } else {      UnpWriteData(this.window, startPtr, endPtr - startPtr);    }  }  private void UnpWriteData(byte[] data, int offset, int size)    throws IOException  {    if (this.writtenFileSize >= this.destUnpSize) {      return;    }    int writeSize = size;    long leftToWrite = this.destUnpSize - this.writtenFileSize;    if (writeSize > leftToWrite) {      writeSize = (int)leftToWrite;    }    this.unpIO.unpWrite(data, offset, writeSize);    this.writtenFileSize += size;  }  private void insertOldDist(int distance)  {    this.oldDist[3] = this.oldDist[2];    this.oldDist[2] = this.oldDist[1];    this.oldDist[1] = this.oldDist[0];    this.oldDist[0] = distance;  }  private void insertLastMatch(int length, int distance)  {    this.lastDist = distance;    this.lastLength = length;  }  private void copyString(int length, int distance)  {    int destPtr = this.unpPtr - distance;    if ((destPtr >= 0) && (destPtr < 4194044) &&       (this.unpPtr < 4194044))    {      this.window[(this.unpPtr++)] = this.window[(destPtr++)];      do      {        this.window[(this.unpPtr++)] = this.window[(destPtr++)];        length--; } while (length > 0);    }    else    {      while (length-- != 0) {        this.window[this.unpPtr] = this.window[(destPtr++ & 0x3FFFFF)];        this.unpPtr = (this.unpPtr + 1 & 0x3FFFFF);      }    }  }  protected void unpInitData(boolean solid) {    if (!solid) {      this.tablesRead = false;      Arrays.fill(this.oldDist, 0);      this.oldDistPtr = 0;      this.lastDist = 0;      this.lastLength = 0;      Arrays.fill(this.unpOldTable, (byte)0);      this.unpPtr = 0;      this.wrPtr = 0;      this.ppmEscChar = 2;      initFilters();    }    InitBitInput();    this.ppmError = false;    this.writtenFileSize = 0L;    this.readTop = 0;    this.readBorder = 0;    unpInitData20(solid);  }  private void initFilters()  {    this.oldFilterLengths.clear();    this.lastFilter = 0;    this.filters.clear();    this.prgStack.clear();  }  private boolean readEndOfBlock() throws IOException, RarException  {    int BitField = getbits();    boolean NewFile = false;    boolean NewTable;    if ((BitField & 0x8000) != 0) {      boolean NewTable = true;      addbits(1);    } else {      NewFile = true;      NewTable = (BitField & 0x4000) != 0;      addbits(2);    }    this.tablesRead = (!NewTable);    return (!NewFile) && ((!NewTable) || (readTables()));  }  private boolean readTables() throws IOException, RarException  {    byte[] bitLength = new byte[20];    byte[] table = new byte[404];    if ((this.inAddr > this.readTop - 25) &&       (!unpReadBuf())) {      return false;    }    faddbits(8 - this.inBit & 0x7);    long bitField = fgetbits() & 0xFFFFFFFF;    if ((bitField & 0x8000) != 0L) {      this.unpBlockType = BlockTypes.BLOCK_PPM;      return this.ppm.decodeInit(this, this.ppmEscChar);    }    this.unpBlockType = BlockTypes.BLOCK_LZ;    this.prevLowDist = 0;    this.lowDistRepCount = 0;    if ((bitField & 0x4000) == 0L) {      Arrays.fill(this.unpOldTable, (byte)0);    }    faddbits(2);    for (int i = 0; i < 20; i++) {      int length = fgetbits() >>> 12 & 0xFF;      faddbits(4);      if (length == 15) {        int zeroCount = fgetbits() >>> 12 & 0xFF;        faddbits(4);        if (zeroCount == 0) {          bitLength[i] = 15;        } else {          zeroCount += 2;          while ((zeroCount-- > 0) && (i < bitLength.length)) {            bitLength[(i++)] = 0;          }          i--;        }      } else {        bitLength[i] = ((byte)length);      }    }    makeDecodeTables(bitLength, 0, this.BD, 20);    int TableSize = 404;    for (int i = 0; i < TableSize; ) {      if ((this.inAddr > this.readTop - 5) &&         (!unpReadBuf())) {        return false;      }      int Number = decodeNumber(this.BD);      if (Number < 16) {        table[i] = ((byte)(Number + this.unpOldTable[i] & 0xF));        i++;      } else if (Number < 18)      {        int N;        if (Number == 16) {          int N = (fgetbits() >>> 13) + 3;          faddbits(3);        } else {          N = (fgetbits() >>> 9) + 11;          faddbits(7);        }        do {          table[i] = table[(i - 1)];          i++;          if (N-- <= 0) break;  } while (i < TableSize);      }      else      {        int N;        if (Number == 18) {          int N = (fgetbits() >>> 13) + 3;          faddbits(3);        } else {          N = (fgetbits() >>> 9) + 11;          faddbits(7);        }        while ((N-- > 0) && (i < TableSize)) {          table[(i++)] = 0;        }      }    }    this.tablesRead = true;    if (this.inAddr > this.readTop) {      return false;    }    makeDecodeTables(table, 0, this.LD, 299);    makeDecodeTables(table, 299, this.DD, 60);    makeDecodeTables(table, 359, this.LDD, 17);    makeDecodeTables(table, 376, this.RD,       28);    for (int i = 0; i < this.unpOldTable.length; i++) {      this.unpOldTable[i] = table[i];    }    return true;  }      if (this.StMode != 0) {        huffDecode();      }      else      {        if (--this.FlagsCnt < 0) {          getFlagsBuf();          this.FlagsCnt = 7;        }        if ((this.FlagBuf & 0x80) != 0) {          this.FlagBuf <<= 1;          if (this.Nlzb > this.Nhfb)            longLZ();          else            huffDecode();        }        else {          this.FlagBuf <<= 1;          if (--this.FlagsCnt < 0) {            getFlagsBuf();            this.FlagsCnt = 7;          }          if ((this.FlagBuf & 0x80) != 0) {            this.FlagBuf <<= 1;            if (this.Nlzb > this.Nhfb)              huffDecode();            else              longLZ();          }          else {            this.FlagBuf <<= 1;            shortLZ();          }        }      }    }    oldUnpWriteBuf();  }  protected boolean unpReadBuf()    throws IOException, RarException  {    int dataSize = this.readTop - this.inAddr;    if (dataSize < 0) {      return false;    }    if (this.inAddr > 16384) {      if (dataSize > 0)      {        System.arraycopy(this.inBuf, this.inAddr, this.inBuf, 0, dataSize);      }      this.inAddr = 0;      this.readTop = dataSize;    }    else {      dataSize = this.readTop;    }    int readCode = this.unpIO.unpRead(this.inBuf, dataSize, 32768 - dataSize & 0xFFFFFFF0);    if (readCode > 0) {      this.readTop += readCode;    }    this.readBorder = (this.readTop - 30);    return readCode != -1;  }public void setPackedSizeToRead(long size)  {    this.unpPackedSize = size;  }  public void setTestMode(boolean mode)  {    this.testMode = mode;  }  public void setSkipUnpCRC(boolean skip)  {    this.skipUnpCRC = skip;  }  public void setSubHeader(FileHeader hd)  {    this.subHead = hd;  }   {    return this.curPackRead;  }  public void setCurPackRead(long curPackRead)  {    this.curPackRead = curPackRead;  }  public long getCurPackWrite()  {    return this.curPackWrite;  }  public void setCurPackWrite(long curPackWrite)  {    this.curPackWrite = curPackWrite;  }  public long getCurUnpRead()  {    return this.curUnpRead;  } private long curPackRead;    this.AvrLn2 += Length;    this.AvrLn2 -= (this.AvrLn2 >>> 5);    BitField = fgetbits();    int DistancePlace;    int DistancePlace;    if (this.AvrPlcB > 10495) {      DistancePlace = decodeNum(BitField, 5, DecHf2, PosHf2);    }    else    {      int DistancePlace;      if (this.AvrPlcB > 1791)        DistancePlace = decodeNum(BitField, 5, DecHf1, PosHf1);      else {        DistancePlace = decodeNum(BitField, 4, DecHf0, PosHf0);      }}} public long getTotalArcSize()  {    return this.totalArcSize;  }  public void setTotalArcSize(long totalArcSize)  {    this.totalArcSize = totalArcSize;  }  public long getTotalPackRead()  {    return this.totalPackRead;  }  public void setTotalPackRead(long totalPackRead)  {    this.totalPackRead = totalPackRead;  }  public long getUnpArcSize()  {    return this.unpArcSize;  }  public void setUnpArcSize(long unpArcSize)  {    this.unpArcSize = unpArcSize;  }  public long getUnpFileCRC()  {    return this.unpFileCRC;  }  public void setUnpFileCRC(long unpFileCRC)  {    this.unpFileCRC = unpFileCRC;  }  public boolean isUnpVolume()  {    return this.unpVolume;  }  public void setUnpVolume(boolean unpVolume)  {    this.unpVolume = unpVolume;  }  public FileHeader getSubHeader()  {    return this.subHead;  }}