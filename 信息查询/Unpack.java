package de.innosystec.xinxichaxun.unpack;import de.innosystec.xinxichaxun.exception.RarException;import de.innosystec.xinxichaxun.rarfile.FileHeader;import de.innosystec.xinxichaxun.unpack.ppm.BlockTypes;import de.innosystec.xinxichaxun.unpack.ppm.ModelPPM;import de.innosystec.xinxichaxun.unpack.ppm.SubAllocator;import de.innosystec.xinxichaxun.unpack.vm.BitInput;import de.innosystec.xinxichaxun.unpack.vm.RarVM;import de.innosystec.xinxichaxun.unpack.vm.VMPreparedProgram;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Vector; public SEE2Context[][] getSEE2Cont()  {    return this.SEE2Cont;  }  public SEE2Context getDummySEE2Cont()  {    return this.dummySEE2Cont;  }  public int getInitRL()  {    return this.initRL;  }}    }    BytePlace &= 255;    if (this.StMode != 0) {      if ((BytePlace == 0) && (BitField > 4095)) {        BytePlace = 256;      }      BytePlace--; if (BytePlace == -1) {        BitField = fgetbits();        faddbits(1);        if ((BitField & 0x8000) != 0) {          this.NumHuf = (this.StMode = 0);          return;        }        int Length = (BitField & 0x4000) != 0 ? 4 : 3;        faddbits(1);        int Distance = decodeNum(fgetbits(), 5, DecHf2, PosHf2);        Distance = Distance << 5 | fgetbits() >>> 11;        faddbits(5);        oldCopyString(Distance, Length);      }    }    else if ((this.NumHuf++ >= 16) && (this.FlagsCnt == 0)) {      this.StMode = 1;    }    this.AvrPlc += BytePlace;    this.AvrPlc -= (this.AvrPlc >>> 8);    this.Nhfb += 16;    if (this.Nhfb > 255) {      this.Nhfb = 144;      this.Nlzb >>>= 1;    }    this.window[(this.unpPtr++)] = ((byte)(this.ChSet[BytePlace] >>> 8));    this.destUnpSize -= 1L;    while (true)    {      int CurByte = this.ChSet[BytePlace];      int tmp421_420 = (CurByte++ & 0xFF);      int[] tmp421_410 = this.NToPl;      int tmp423_422 = tmp421_410[tmp421_420]; tmp421_410[tmp421_420] = (tmp423_422 + 1); int NewBytePlace = tmp423_422;      if ((CurByte & 0xFF) <= 161) break;      corrHuff(this.ChSet, this.NToPl);    }    int NewBytePlace;    int CurByte;    this.ChSet[BytePlace] = this.ChSet[NewBytePlace];    this.ChSet[NewBytePlace] = CurByte;  }  protected void getFlagsBuf()  {    int FlagsPlace = decodeNum(fgetbits(), 5, DecHf2, PosHf2);    while (true)    {      int Flags = this.ChSetC[FlagsPlace];      this.FlagBuf = (Flags >>> 8);      int tmp43_42 = (Flags++ & 0xFF);      int[] tmp43_32 = this.NToPlC;      int tmp45_44 = tmp43_32[tmp43_42]; tmp43_32[tmp43_42] = (tmp45_44 + 1); int NewFlagsPlace = tmp45_44;      if ((Flags & 0xFF) != 0) {        break;      }      corrHuff(this.ChSetC, this.NToPlC);    }    int NewFlagsPlace;    int Flags;    this.ChSetC[FlagsPlace] = this.ChSetC[NewFlagsPlace];    this.ChSetC[NewFlagsPlace] = Flags;  }  protected void oldUnpInitData(boolean Solid)  {    if (!Solid) {      this.AvrPlcB = (this.AvrLn1 = this.AvrLn2 = this.AvrLn3 = this.NumHuf = this.Buf60 = 0);      this.AvrPlc = 13568;      this.MaxDist3 = 8193;      this.Nhfb = (this.Nlzb = 'â‚¬');    }    this.FlagsCnt = 0;    this.FlagBuf = 0;    this.StMode = 0;    this.LCount = 0;    this.readTop = 0;  }  protected void initHuff()  {    for (int I = 0; I < 256; I++)    {      int tmp23_22 = (this.PlaceB[I] = I); this.PlaceA[I] = tmp23_22; this.Place[I] = tmp23_22;      this.PlaceC[I] = ((I ^ 0xFFFFFFFF) + 1 & 0xFF);      int tmp55_54 = (I << 8); this.ChSetB[I] = tmp55_54; this.ChSet[I] = tmp55_54;      this.ChSetA[I] = I;      this.ChSetC[I] = (((I ^ 0xFFFFFFFF) + 1 & 0xFF) << 8);    }    Arrays.fill(this.NToPl, 0);    Arrays.fill(this.NToPlB, 0);    Arrays.fill(this.NToPlC, 0);    corrHuff(this.ChSetB, this.NToPlB);  }public final class Unpack extends Unpack20{  private final ModelPPM ppm = new ModelPPM();  private int ppmEscChar;  private RarVM rarVM = new RarVM();  private List<UnpackFilter> filters = new ArrayList();  private List<UnpackFilter> prgStack = new ArrayList();  private List<Integer> oldFilterLengths = new ArrayList();  private int lastFilter;  private boolean tablesRead;  private byte[] unpOldTable = new byte[404];  private BlockTypes unpBlockType;  private boolean externalWindow;  private long writtenFileSize;  private boolean fileExtracted;  private boolean ppmError;  private int prevLowDist;  private int lowDistRepCount;  public static int[] DBitLengthCounts = { 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,     2, 2, 2, 2, 2, 14, 0, 12 };  public Unpack(ComprDataIO DataIO)  {    this.unpIO = DataIO;    this.window = null;    this.externalWindow = false;    this.suspended = false;    this.unpAllBuf = false;    this.unpSomeRead = false;  }  public void init(byte[] window)  {    if (window == null) {      this.window = new byte[4194304];    } else {      this.window = window;      this.externalWindow = true;    }    this.inAddr = 0;    unpInitData(false);  }  public void doUnpack(int method, boolean solid) throws IOException, RarException  {    if (this.unpIO.getSubHeader().getUnpMethod() == 48) {      unstoreFile();    }    switch (method) {    case 15:      unpack15(solid);      break;    case 20:    case 26:      unpack20(solid);          case 29:    case 36:      unpack29(solid);    }  }  private void unstoreFile()    throws IOException, RarException  {    byte[] buffer = new byte[65536];    while (true) {      int code = this.unpIO.unpRead(buffer, 0, (int)Math.min(buffer.length, this.destUnpSize));      if ((code == 0) || (code == -1))        break;      code = code < this.destUnpSize ? code : (int)this.destUnpSize;      this.unpIO.unpWrite(buffer, 0, code);      if (this.destUnpSize >= 0L)        this.destUnpSize -= code;    }  }  private void unpack29(boolean solid)    throws IOException, RarException  {    int[] DDecode = new int[60];    byte[] DBits = new byte[60];    if (DDecode[1] == 0) {      int Dist = 0; int BitLength = 0; int Slot = 0;      for (int I = 0; I < DBitLengthCounts.length; BitLength++) {        int count = DBitLengthCounts[I];        for (int J = 0; J < count; Dist += (1 << BitLength)) {          DDecode[Slot] = Dist;          DBits[Slot] = ((byte)BitLength);          J++; Slot++;        }        I++;      }    }    this.fileExtracted = true;    if (!this.suspended) {      unpInitData(solid);      if (!unpReadBuf()) {        return;      }      if (((!solid) || (!this.tablesRead)) && (!readTables())) {        return;      }    }    if (this.ppmError) {      return;    }    while (true)    {      this.unpPtr &= 4194303;      if ((this.inAddr > this.readBorder) &&         (!unpReadBuf()))      {        break;      }      if (((this.wrPtr - this.unpPtr & 0x3FFFFF) < 260) &&         (this.wrPtr != this.unpPtr))      {        UnpWriteBuf();        if (this.writtenFileSize > this.destUnpSize) {          return;        }        if (this.suspended) {          this.fileExtracted = false;          return;        }      }  private boolean readVMCode()    throws IOException, RarException  {    int FirstByte = getbits() >> 8;    addbits(8);    int Length = (FirstByte & 0x7) + 1;    if (Length == 7) {      Length = (getbits() >> 8) + 7;      addbits(8);    } else if (Length == 8) {      Length = getbits();      addbits(16);    }    List vmCode = new ArrayList();    for (int I = 0; I < Length; I++) {      if ((this.inAddr >= this.readTop - 1) && (!unpReadBuf()) && (I < Length - 1)) {        return false;      }      vmCode.add(Byte.valueOf((byte)(getbits() >> 8)));      addbits(8);    }    return addVMCode(FirstByte, vmCode, Length);  }  private boolean readVMCodePPM() throws IOException, RarException  {    int FirstByte = this.ppm.decodeChar();    if (FirstByte == -1) {      return false;    }    int Length = (FirstByte & 0x7) + 1;    if (Length == 7) {      int B1 = this.ppm.decodeChar();      if (B1 == -1) {        return false;      }      Length = B1 + 7;    } else if (Length == 8) {      int B1 = this.ppm.decodeChar();      if (B1 == -1) {        return false;      }      int B2 = this.ppm.decodeChar();      if (B2 == -1) {        return false;      }      Length = B1 * 256 + B2;    }    List vmCode = new ArrayList();    for (int I = 0; I < Length; I++) {      int Ch = this.ppm.decodeChar();      if (Ch == -1) {        return false;      }      vmCode.add(Byte.valueOf((byte)Ch));    }    return addVMCode(FirstByte, vmCode, Length);  }  private boolean addVMCode(int firstByte, List<Byte> vmCode, int length)  {    BitInput Inp = new BitInput();    Inp.InitBitInput();    for (int i = 0; i < Math.min(32768, vmCode.size()); i++) {      Inp.getInBuf()[i] = ((Byte)vmCode.get(i)).byteValue();    }    this.rarVM.init();    int FiltPos;    if ((firstByte & 0x80) != 0) {      int FiltPos = RarVM.ReadData(Inp);      if (FiltPos == 0)        initFilters();      else        FiltPos--;    }    else {      FiltPos = this.lastFilter;    }    if ((FiltPos > this.filters.size()) || (FiltPos > this.oldFilterLengths.size())) {      return false;    }    this.lastFilter = FiltPos;    boolean NewFilter = FiltPos == this.filters.size();    UnpackFilter StackFilter = new UnpackFilter();    UnpackFilter Filter;    if (NewFilter)    {      if (FiltPos > 1024) {        return false;      }      UnpackFilter Filter = new UnpackFilter();      this.filters.add(Filter);      StackFilter.setParentFilter(this.filters.size() - 1);      this.oldFilterLengths.add(Integer.valueOf(0));      Filter.setExecCount(0);    }    else {      Filter = (UnpackFilter)this.filters.get(FiltPos);      StackFilter.setParentFilter(FiltPos);      Filter.setExecCount(Filter.getExecCount() + 1);    }    this.prgStack.add(StackFilter);    StackFilter.setExecCount(Filter.getExecCount());    int BlockStart = RarVM.ReadData(Inp);    if ((firstByte & 0x40) != 0) {      BlockStart += 258;    }    StackFilter.setBlockStart(BlockStart + this.unpPtr & 0x3FFFFF);    if ((firstByte & 0x20) != 0)      StackFilter.setBlockLength(RarVM.ReadData(Inp));    else {      StackFilter        .setBlockLength(FiltPos < this.oldFilterLengths.size() ?         ((Integer)this.oldFilterLengths.get(FiltPos)).intValue() :         0);    }    StackFilter.setNextWindow((this.wrPtr != this.unpPtr) &&       ((this.wrPtr - this.unpPtr & 0x3FFFFF) <= BlockStart));    this.oldFilterLengths.set(FiltPos, Integer.valueOf(StackFilter.getBlockLength()));    Arrays.fill(StackFilter.getPrg().getInitR(), 0);    StackFilter.getPrg().getInitR()[3] = 245760;    StackFilter.getPrg().getInitR()[4] = StackFilter.getBlockLength();    StackFilter.getPrg().getInitR()[5] = StackFilter.getExecCount();    if ((firstByte & 0x10) != 0)    {      int InitMask = Inp.fgetbits() >>> 9;      Inp.faddbits(7);      for (int I = 0; I < 7; I++) {        if ((InitMask & 1 << I) != 0)        {          StackFilter.getPrg().getInitR()[I] = RarVM.ReadData(Inp);    }  }} protected void shortLZ()  {    this.NumHuf = 0;    int BitField = fgetbits();    if (this.LCount == 2) {      faddbits(1);      if (BitField >= 32768) {        oldCopyString(this.lastDist, this.lastLength);        return;      }      BitField <<= 1;      this.LCount = 0;    }    BitField >>>= 8;    int Length;    if (this.AvrLn1 < 37) {      int Length = 0;      while (((BitField ^ ShortXor1[Length]) & (255 >>> getShortLen1(Length) ^ 0xFFFFFFFF)) != 0) {        Length++;      }      faddbits(getShortLen1(Length));    } else {      Length = 0;      while (((BitField ^ ShortXor2[Length]) & (255 >> getShortLen2(Length) ^ 0xFFFFFFFF)) != 0) {        Length++;      }      faddbits(getShortLen2(Length));    }    if (Length >= 9) {      if (Length == 9) {        this.LCount += 1;        oldCopyString(this.lastDist, this.lastLength);        return;      }      if (Length == 14) {        this.LCount = 0;        Length = decodeNum(fgetbits(), 3, DecL2, PosL2) + 5;        int Distance = fgetbits() >> 1 | 0x8000;        faddbits(15);        this.lastLength = Length;        this.lastDist = Distance;        oldCopyString(Distance, Length);        return;      }      this.LCount = 0;      int SaveLength = Length;      int Distance = this.oldDist[(this.oldDistPtr - (Length - 9) & 0x3)];      Length = decodeNum(fgetbits(), 2, DecL1, PosL1) + 2;      if ((Length == 257) && (SaveLength == 10)) {        this.Buf60 ^= 1;        return;      }      if (Distance > 256)        Length++;      if (Distance >= this.MaxDist3) {        Length++;      }      this.oldDist[(this.oldDistPtr++)] = Distance;      this.oldDistPtr &= 3;      this.lastLength = Length;      this.lastDist = Distance;      oldCopyString(Distance, Length);      return;    }    this.LCount = 0;    this.AvrLn1 += Length;    this.AvrLn1 -= (this.AvrLn1 >> 4);    int DistancePlace = decodeNum(fgetbits(), 5, DecHf2, PosHf2) & 0xFF;    int Distance = this.ChSetA[DistancePlace];    DistancePlace--; if (DistancePlace != -1) {      this.PlaceA[Distance] -= 1;      int LastDistance = this.ChSetA[DistancePlace];      this.PlaceA[LastDistance] += 1;      this.ChSetA[(DistancePlace + 1)] = LastDistance;      this.ChSetA[DistancePlace] = Distance;    }    Length += 2;    this.oldDist[(this.oldDistPtr++)] = (++Distance);    this.oldDistPtr &= 3;    this.lastDist = Distance;    oldCopyString(Distance, Length);  }  protected void longLZ()  {    this.NumHuf = 0;    this.Nlzb += 16;    if (this.Nlzb > 255) {      this.Nlzb = 144;      this.Nhfb >>>= 1;    }    int OldAvr2 = this.AvrLn2;    int BitField = fgetbits();    int Length;    int Length;    if (this.AvrLn2 >= 122) {      Length = decodeNum(BitField, 3, DecL2, PosL2);    }    else    {      int Length;      if (this.AvrLn2 >= 64) {        Length = decodeNum(BitField, 2, DecL1, PosL1);      }      else if (BitField < 256) {        int Length = BitField;        faddbits(16);      } else {        for (Length = 0; (BitField << Length & 0x8000) == 0; Length++);        faddbits(Length + 1);      }}  }public int decodeChar()    throws IOException, RarException  {    if ((this.minContext.getAddress() <= this.subAlloc.getPText()) ||       (this.minContext.getAddress() > this.subAlloc.getHeapEnd())) {      return -1;    }    if (this.minContext.getNumStats() != 1) {      if ((this.minContext.getFreqData().getStats() <= this.subAlloc.getPText()) ||         (this.minContext.getFreqData().getStats() > this.subAlloc.getHeapEnd())) {        return -1;      }      if (!this.minContext.decodeSymbol1(this))        return -1;    }    else {      this.minContext.decodeBinSymbol(this);    }      while (this.minContext.getNumStats() == this.numMasked);      if (!this.minContext.decodeSymbol2(this)) {        return -1;      }      this.coder.decode();    }    int Symbol = this.foundState.getSymbol();    if ((this.orderFall == 0) && (this.foundState.getSuccessor() > this.subAlloc.getPText()))    {      int addr = this.foundState.getSuccessor();      this.minContext.setAddress(addr);      this.maxContext.setAddress(addr);    } else {      updateModel();      if (this.escCount == 0) {        clearMask();      }    }    this.coder.ariDecNormalize();    return Symbol;  }public static BlockTypes findBlockType(int blockType)  {    if (BLOCK_LZ.equals(blockType)) {      return BLOCK_LZ;    }    if (BLOCK_PPM.equals(blockType)) {      return BLOCK_PPM;    }    return null;  }}