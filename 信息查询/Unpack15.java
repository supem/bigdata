package de.innosystec.xinxichaxun.unpack.ppm;import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintStream; public boolean isFileExtracted()  {    return this.fileExtracted;  }  public void setDestSize(long destSize)  {    this.destUnpSize = destSize;    this.fileExtracted = false;  }  public void setSuspended(boolean suspended)  {    this.suspended = suspended;  }  public int getChar() throws IOException, RarException  {    if (this.inAddr > 32738) {      unpReadBuf();    }    return this.inBuf[(this.inAddr++)] & 0xFF;  }  public int getPpmEscChar()  {    return this.ppmEscChar;  }  public void setPpmEscChar(int ppmEscChar)  {    this.ppmEscChar = ppmEscChar;  }  public void cleanUp() {   if (this.ppm != null) {   SubAllocator allocator = this.ppm.getSubAlloc();  if (allocator != null) allocator.stopSubAllocator(); }} public boolean decodeInit(Unpack unpackRead, int escChar)    throws IOException, RarException  {    int MaxOrder = unpackRead.getChar() & 0xFF;    boolean reset = (MaxOrder & 0x20) != 0;    int MaxMB = 0;    if (reset) {      MaxMB = unpackRead.getChar();    }    else if (this.subAlloc.GetAllocatedMemory() == 0) {      return false;    }    if ((MaxOrder & 0x40) != 0) {      escChar = unpackRead.getChar();      unpackRead.setPpmEscChar(escChar);    }    this.coder.initDecoder(unpackRead);    if (reset) {      MaxOrder = (MaxOrder & 0x1F) + 1;      if (MaxOrder > 16) {        MaxOrder = 16 + (MaxOrder - 16) * 3;      }      if (MaxOrder == 1) {        this.subAlloc.stopSubAllocator();        return false;      }      this.subAlloc.startSubAllocator(MaxMB + 1);      this.minContext = new PPMContext(getHeap());      this.medContext = new PPMContext(getHeap());      this.maxContext = new PPMContext(getHeap());      this.foundState = new State(getHeap());      this.dummySEE2Cont = new SEE2Context();      for (int i = 0; i < 25; i++) {        for (int j = 0; j < 16; j++) {          this.SEE2Cont[i][j] = new SEE2Context();        }      }      startModelRare(MaxOrder);    }    return this.minContext.getAddress() != 0;  } protected void unpack20(boolean solid)    throws IOException, RarException  {    if (this.suspended) {      this.unpPtr = this.wrPtr;    } else {      unpInitData(solid);      if (!unpReadBuf()) {        return;      }      if ((!solid) &&         (!ReadTables20())) {        return;      }      this.destUnpSize -= 1L;    }    while (this.destUnpSize >= 0L) {      this.unpPtr &= 4194303;      if ((this.inAddr > this.readTop - 30) &&         (!unpReadBuf()))        break;      if (((this.wrPtr - this.unpPtr & 0x3FFFFF) < 270) &&         (this.wrPtr != this.unpPtr)) {        oldUnpWriteBuf();        if (this.suspended)          return;      }      if (this.UnpAudioBlock != 0) {        int AudioNumber = decodeNumber(this.MD[this.UnpCurChannel]);        if (AudioNumber == 256) {          if (!ReadTables20())            break;        }        else {          this.window[(this.unpPtr++)] = DecodeAudio(AudioNumber);          if (++this.UnpCurChannel == this.UnpChannels)            this.UnpCurChannel = 0;          this.destUnpSize -= 1L;        }      }      else {        int Number = decodeNumber(this.LD);        if (Number < 256) {          this.window[(this.unpPtr++)] = ((byte)Number);          this.destUnpSize -= 1L;        }        else if (Number > 269) {          Number -= 270; int Length = LDecode[Number] + 3;          int Bits;          if ((Bits = LBits[Number]) > 0) {            Length += (getbits() >>> 16 - Bits);            addbits(Bits);          }          int DistNumber = decodeNumber(this.DD);          int Distance = DDecode[DistNumber] + 1;          if ((Bits = DBits[DistNumber]) > 0) {            Distance += (getbits() >>> 16 - Bits);            addbits(Bits);          }          if (Distance >= 8192) {            Length++;            if (Distance >= 262144L) {              Length++;            }          }          CopyString20(Length, Distance);        }        else if (Number == 269) {          if (!ReadTables20()) {            break;          }        }        else if (Number == 256) {          CopyString20(this.lastLength, this.lastDist);        }        else if (Number < 261) {          int Distance = this.oldDist[(this.oldDistPtr - (Number - 256) & 0x3)];          int LengthNumber = decodeNumber(this.RD);          int Length = LDecode[LengthNumber] + 2;          int Bits;          if ((Bits = LBits[LengthNumber]) > 0) {            Length += (getbits() >>> 16 - Bits);            addbits(Bits);          }          if (Distance >= 257) {            Length++;            if (Distance >= 8192) {              Length++;              if (Distance >= 262144)                Length++;            }          }        }          CopyString20(Length, Distance);        }        else if (Number < 270) {          Number -= 261; int Distance = SDDecode[Number] + 1;          int Bits;          if ((Bits = SDBits[Number]) > 0) {            Distance += (getbits() >>> 16 - Bits);            addbits(Bits);          }       CopyString20(2, Distance);     }   } }public SubAllocator getSubAlloc()  {    return this.subAlloc;  }  private void restartModelRare()  {    Arrays.fill(this.charMask, 0);    this.subAlloc.initSubAllocator();    this.initRL = (-(this.maxOrder < 12 ? this.maxOrder : 12) - 1);    int addr = this.subAlloc.allocContext();    this.minContext.setAddress(addr);    this.maxContext.setAddress(addr);    this.minContext.setSuffix(0);    this.orderFall = this.maxOrder;    this.minContext.setNumStats(256);    this.minContext.getFreqData().setSummFreq(this.minContext.getNumStats() + 1);    addr = this.subAlloc.allocUnits(128);    this.foundState.setAddress(addr);    this.minContext.getFreqData().setStats(addr);    State state = new State(this.subAlloc.getHeap());    addr = this.minContext.getFreqData().getStats();    this.runLength = this.initRL;    this.prevSuccess = 0;    for (int i = 0; i < 256; i++) {      state.setAddress(addr + i * 6);      state.setSymbol(i);      state.setFreq(1);      state.setSuccessor(0);    }    for (int i = 0; i < 128; i++) {      for (int k = 0; k < 8; k++) {        for (int m = 0; m < 64; m += 8) {          this.binSumm[i][(k + m)] = (16384 - InitBinEsc[k] / (i + 2));        }      }    }    for (int i = 0; i < 25; i++)  {    this.escCount = 1;    Arrays.fill(this.charMask, 0);  }  public boolean decodeInit(Unpack unpackRead, int escChar)    throws IOException, RarException  {    int MaxOrder = unpackRead.getChar() & 0xFF;    boolean reset = (MaxOrder & 0x20) != 0;    int MaxMB = 0;    if (reset) {      MaxMB = unpackRead.getChar();    }    else if (this.subAlloc.GetAllocatedMemory() == 0) {      return false;    }    if ((MaxOrder & 0x40) != 0) {      escChar = unpackRead.getChar();      unpackRead.setPpmEscChar(escChar);    }    if (reset) {      MaxOrder = (MaxOrder & 0x1F) + 1;      if (MaxOrder > 16) {        MaxOrder = 16 + (MaxOrder - 16) * 3;      }      if (MaxOrder == 1) {        this.subAlloc.stopSubAllocator();        return false;      }      this.subAlloc.startSubAllocator(MaxMB + 1);      this.minContext = new PPMContext(getHeap());      this.medContext = new PPMContext(getHeap());      this.maxContext = new PPMContext(getHeap());      this.foundState = new State(getHeap());      this.dummySEE2Cont = new SEE2Context();      for (int i = 0; i < 25; i++) {        for (int j = 0; j < 16; j++) {          this.SEE2Cont[i][j] = new SEE2Context();        }      }      startModelRare(MaxOrder);    }    return this.minContext.getAddress() != 0;  }public int decodeChar()    throws IOException, RarException  {    if ((this.minContext.getAddress() <= this.subAlloc.getPText()) ||       (this.minContext.getAddress() > this.subAlloc.getHeapEnd())) {      return -1;    }    if (this.minContext.getNumStats() != 1) {      if ((this.minContext.getFreqData().getStats() <= this.subAlloc.getPText()) ||         (this.minContext.getFreqData().getStats() > this.subAlloc.getHeapEnd())) {        return -1;      }      if (!this.minContext.decodeSymbol1(this))        return -1;    }    else {      this.minContext.decodeBinSymbol(this);    }      while (this.minContext.getNumStats() == this.numMasked);      if (!this.minContext.decodeSymbol2(this)) {        return -1;      }      this.coder.decode();    }    int Symbol = this.foundState.getSymbol();    if ((this.orderFall == 0) && (this.foundState.getSuccessor() > this.subAlloc.getPText()))    {      int addr = this.foundState.getSuccessor();      this.minContext.setAddress(addr);      this.maxContext.setAddress(addr);    } else {      updateModel();      if (this.escCount == 0) {        clearMask();      }    }    this.coder.ariDecNormalize();    return Symbol;  }  private static void printMismatch(long startOff, long bytesRead) {    System.out.println("Mismatch: off=" + startOff +       "(0x" + Long.toHexString(startOff) +       "), len=" + (bytesRead - startOff));  }}