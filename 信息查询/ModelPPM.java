package de.innosystec.xinxichaxun.unpack.ppm;public enum BlockTypes{  BLOCK_LZ(0), BLOCK_PPM(1);  private int blockType;  private BlockTypes(int blockType)  {    this.blockType = blockType;  }  public int getBlockType()  {    return this.blockType;  }  public boolean equals(int blockType)  {    return this.blockType == blockType;  }private boolean unpVolume;  private boolean nextVolumeMissing;  private long totalPackRead;  private long unpArcSize;    this.AvrPlcB += DistancePlace;    this.AvrPlcB -= (this.AvrPlcB >> 8);    while (true) {      int Distance = this.ChSetB[(DistancePlace & 0xFF)];      int tmp300_299 = (Distance++ & 0xFF);      int[] tmp300_289 = this.NToPlB;      int tmp302_301 = tmp300_289[tmp300_299]; tmp300_289[tmp300_299] = (tmp302_301 + 1); int NewDistancePlace = tmp302_301;      if ((Distance & 0xFF) != 0) break;      corrHuff(this.ChSetB, this.NToPlB);    }    int NewDistancePlace;    this.ChSetB[DistancePlace] = this.ChSetB[NewDistancePlace];    this.ChSetB[NewDistancePlace] = Distance;    int Distance = (Distance & 0xFF00 | fgetbits() >>> 8) >>> 1;    faddbits(7);    int OldAvr3 = this.AvrLn3;    if ((Length != 1) && (Length != 4)) {      if ((Length == 0) && (Distance <= this.MaxDist3)) {        this.AvrLn3 += 1;        this.AvrLn3 -= (this.AvrLn3 >> 8);      }      else if (this.AvrLn3 > 0) {        this.AvrLn3 -= 1;      }    }    Length += 3;    if (Distance >= this.MaxDist3) {      Length++;    }    if (Distance <= 256) {      Length += 8;    }    if ((OldAvr3 > 176) || ((this.AvrPlc >= 10752) && (OldAvr2 < 64)))      this.MaxDist3 = 32512;    else {      this.MaxDist3 = 8193;    }    this.oldDist[(this.oldDistPtr++)] = Distance;    this.oldDistPtr &= 3;    this.lastLength = Length;    this.lastDist = Distance;    oldCopyString(Distance, Length);  }  protected void huffDecode()  {    int BitField = fgetbits();    int BytePlace;    int BytePlace;    if (this.AvrPlc > 30207) {      BytePlace = decodeNum(BitField, 8, DecHf4, PosHf4);    }    else    {      int BytePlace;      if (this.AvrPlc > 24063) {        BytePlace = decodeNum(BitField, 6, DecHf3, PosHf3);      }      else      {        int BytePlace;        if (this.AvrPlc > 13823) {          BytePlace = decodeNum(BitField, 5, DecHf2, PosHf2);        }        else        {          int BytePlace;          if (this.AvrPlc > 3583)            BytePlace = decodeNum(BitField, 5, DecHf1,               PosHf1);          else {        BytePlace = decodeNum(BitField, 4, DecHf0,        PosHf0);     }   } }public class AnalyzeHeapDump{  public static void main(String[] argv)  {    File cfile = new File("P:\\test\\heapdumpc");    File jfile = new File("P:\\test\\heapdumpj");    if (!cfile.exists()) {      System.err.println("File not found: " + cfile.getAbsolutePath());      return;    }    if (!jfile.exists()) {      System.err.println("File not found: " + jfile.getAbsolutePath());      return;    }    long clen = cfile.length();    long jlen = jfile.length();    if (clen != jlen) {      System.out.println("File size mismatch");      System.out.println("clen = " + clen);      System.out.println("jlen = " + jlen);    }    long len = Math.min(clen, jlen);    InputStream cin = null;    InputStream jin = null;    int bufferLen = 262144;    try {      cin = new BufferedInputStream(        new FileInputStream(cfile), bufferLen);      jin = new BufferedInputStream(        new FileInputStream(jfile), bufferLen);      boolean matching = true;      boolean mismatchFound = false;      long startOff = 0L;      long off = 0L;      while (off < len) {        if (cin.read() != jin.read()) {          if (matching) {            startOff = off;            matching = false;            mismatchFound = true;          }        }        else if (!matching) {          printMismatch(startOff, off);          matching = true;        }        off += 1L;      }      if (!matching) {        printMismatch(startOff, off);      }      if (!mismatchFound) {        System.out.println("Files are identical");      }      System.out.println("Done");} }    catch (IOException e) {      e.printStackTrace();      try      {        cin.close();        jin.close();      } catch (IOException e) {        e.printStackTrace();      }    }    finally    {      try      {        cin.close();        jin.close();      } catch (IOException e) {      e.printStackTrace();     }   } }public class ModelPPM{  public static final int MAX_O = 64;  public static final int INT_BITS = 7;  public static final int PERIOD_BITS = 7;  public static final int TOT_BITS = 14;  public static final int INTERVAL = 128;  public static final int BIN_SCALE = 16384;  public static final int MAX_FREQ = 124;  private SEE2Context[][] SEE2Cont = new SEE2Context[25][16];  private SEE2Context dummySEE2Cont;  private PPMContext minContext;  private PPMContext medContext;  private PPMContext maxContext;  private State foundState;  private int numMasked;  private int initEsc;  private int orderFall;  private int maxOrder;  private int runLength;  private int initRL;  private int[] charMask = new int[256];  private int[] NS2Indx = new int[256];  private int[] NS2BSIndx = new int[256];  private int[] HB2Flag = new int[256];  private int escCount;  private int prevSuccess;  private int hiBitsFlag;  private int[][] binSumm = new int['â‚¬'][64];  private RangeCoder coder = new RangeCoder();  private SubAllocator subAlloc = new SubAllocator();  private static int[] InitBinEsc = { 15581, 7999, 22975, 18675,     25761, 23228, 26162, 24657 };  private final State tempState1 = new State(null);  private final State tempState2 = new State(null);  private final State tempState3 = new State(null);  private final State tempState4 = new State(null);  private final StateRef tempStateRef1 = new StateRef();  private final StateRef tempStateRef2 = new StateRef();  private final PPMContext tempPPMContext1 = new PPMContext(null);  private final PPMContext tempPPMContext2 = new PPMContext(null);  private final PPMContext tempPPMContext3 = new PPMContext(null);  private final PPMContext tempPPMContext4 = new PPMContext(null);  private final int[] ps = new int[64];  public ModelPPM()  {    this.minContext = null;    this.maxContext = null;    this.medContext = null;  }  public SubAllocator getSubAlloc()  {    return this.subAlloc;  }  private void restartModelRare()  {    Arrays.fill(this.charMask, 0);    this.subAlloc.initSubAllocator();    this.initRL = (-(this.maxOrder < 12 ? this.maxOrder : 12) - 1);    int addr = this.subAlloc.allocContext();    this.minContext.setAddress(addr);    this.maxContext.setAddress(addr);    this.minContext.setSuffix(0);    this.orderFall = this.maxOrder;    this.minContext.setNumStats(256);    this.minContext.getFreqData().setSummFreq(this.minContext.getNumStats() + 1);    addr = this.subAlloc.allocUnits(128);    this.foundState.setAddress(addr);    this.minContext.getFreqData().setStats(addr);    State state = new State(this.subAlloc.getHeap());    addr = this.minContext.getFreqData().getStats();    this.runLength = this.initRL;    this.prevSuccess = 0;    for (int i = 0; i < 256; i++) {      state.setAddress(addr + i * 6);      state.setSymbol(i);      state.setFreq(1);      state.setSuccessor(0);    }    for (int i = 0; i < 128; i++) {      for (int k = 0; k < 8; k++) {        for (int m = 0; m < 64; m += 8) {          this.binSumm[i][(k + m)] = (16384 - InitBinEsc[k] / (i + 2));        }      }    }    for (int i = 0; i < 25; i++)  {    this.escCount = 1;    Arrays.fill(this.charMask, 0);  }    ReadLastTables();    oldUnpWriteBuf();  }    Arrays.fill(NumToPlace, 0);    for (I = 6; I >= 0; I--)      NumToPlace[I] = ((7 - I) * 32);  }protected void oldCopyString(int Distance, int Length)  {    this.destUnpSize -= Length;    while (Length-- != 0) {      this.window[this.unpPtr] = this.window[(this.unpPtr - Distance & 0x3FFFFF)];      this.unpPtr = (this.unpPtr + 1 & 0x3FFFFF);    }  }  protected int decodeNum(int Num, int StartPos, int[] DecTab, int[] PosTab)  {    Num &= 65520; for (int I = 0; DecTab[I] <= Num; I++) {      StartPos++;    }    faddbits(StartPos);    return (Num - (I != 0 ? DecTab[(I - 1)] : 0) >>> 16 - StartPos) + PosTab[StartPos];  }  protected void oldUnpWriteBuf() throws IOException  {    if (this.unpPtr != this.wrPtr) {      this.unpSomeRead = true;    }    if (this.unpPtr < this.wrPtr) {      this.unpIO.unpWrite(this.window, this.wrPtr, -this.wrPtr & 0x3FFFFF);      this.unpIO.unpWrite(this.window, 0, this.unpPtr);      this.unpAllBuf = true;    } else {      this.unpIO.unpWrite(this.window, this.wrPtr, this.unpPtr - this.wrPtr);    }    this.wrPtr = this.unpPtr;  }    protected int UnpCurChannel;  protected int UnpChannelDelta;  protected AudioVariables[] AudV = new AudioVariables[4];  protected LitDecode LD = new LitDecode();  protected DistDecode DD = new DistDecode();  protected LowDistDecode LDD = new LowDistDecode();  protected RepDecode RD = new RepDecode();  protected BitDecode BD = new BitDecode();  public static final int[] LDecode = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12,     14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192,     224 };  public static final byte[] LBits = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2,     2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5 };  public static final int[] DDecode = { 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32,     48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072,     4096, 6144, 8192, 12288, 16384, 24576, 32768, 49152, 65536, 98304,     131072, 196608, 262144, 327680, 393216, 458752, 524288, 589824,     655360, 720896, 786432, 851968, 917504, 983040 };  public static final int[] DBits = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5,     5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14,     15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 };  public static final int[] SDDecode = { 0, 4, 8, 16, 32, 64, 128, 192 };  public static final int[] SDBits = { 2, 2, 3, 4, 5, 6, 6, 6 }; public int decodeChar()    throws IOException, RarException  {    if ((this.minContext.getAddress() <= this.subAlloc.getPText()) ||       (this.minContext.getAddress() > this.subAlloc.getHeapEnd())) {      return -1;    }    if (this.minContext.getNumStats() != 1) {      if ((this.minContext.getFreqData().getStats() <= this.subAlloc.getPText()) ||         (this.minContext.getFreqData().getStats() > this.subAlloc.getHeapEnd())) {        return -1;      }      if (!this.minContext.decodeSymbol1(this))        return -1;    }    else {      this.minContext.decodeBinSymbol(this);    }      while (this.minContext.getNumStats() == this.numMasked);      if (!this.minContext.decodeSymbol2(this)) {        return -1;      }      this.coder.decode();    }    int Symbol = this.foundState.getSymbol();    if ((this.orderFall == 0) && (this.foundState.getSuccessor() > this.subAlloc.getPText()))    {      }      UnpackFilter Filter = new UnpackFilter();      this.filters.add(Filter);      StackFilter.setParentFilter(this.filters.size() - 1);      this.oldFilterLengths.add(Integer.valueOf(0));      Filter.setExecCount(0);    }    else {      Filter = (UnpackFilter)this.filters.get(FiltPos);      StackFilter.setParentFilter(FiltPos);      Filter.setExecCount(Filter.getExecCount() + 1);    }    this.prgStack.add(StackFilter);    StackFilter.setExecCount(Filter.getExecCount());    int BlockStart = RarVM.ReadData(Inp);    if ((firstByte & 0x40) != 0) {      BlockStart += 258;    }    StackFilter.setBlockStart(BlockStart + this.unpPtr & 0x3FFFFF);    if ((firstByte & 0x20) != 0)      StackFilter.setBlockLength(RarVM.ReadData(Inp));    else {      StackFilter        .setBlockLength(FiltPos < this.oldFilterLengths.size() ?         ((Integer)this.oldFilterLengths.get(FiltPos)).intValue() :         0);    }    StackFilter.setNextWindow((this.wrPtr != this.unpPtr) &&       ((this.wrPtr - this.unpPtr & 0x3FFFFF) <= BlockStart));    this.oldFilterLengths.set(FiltPos, Integer.valueOf(StackFilter.getBlockLength()));    Arrays.fill(StackFilter.getPrg().getInitR(), 0);    StackFilter.getPrg().getInitR()[3] = 245760;    StackFilter.getPrg().getInitR()[4] = StackFilter.getBlockLength();    StackFilter.getPrg().getInitR()[5] = StackFilter.getExecCount();    if ((firstByte & 0x10) != 0)    {      int InitMask = Inp.fgetbits() >>> 9;      Inp.faddbits(7);      for (int I = 0; I < 7; I++) {        if ((InitMask & 1 << I) != 0)        {          StackFilter.getPrg().getInitR()[I] = RarVM.ReadData(Inp);     }   }}